// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Ghaarp/auth/internal/service.ServiceConverter -o service_converter_minimock.go -n ServiceConverterMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Ghaarp/auth/internal/service/auth/model"
	generated "github.com/Ghaarp/auth/pkg/auth_v1"
	"github.com/gojuno/minimock/v3"
)

// ServiceConverterMock implements mm_service.ServiceConverter
type ServiceConverterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcToProtoGetResponse          func(data *model.UserDataPublic) (gp1 *generated.GetResponse)
	funcToProtoGetResponseOrigin    string
	inspectFuncToProtoGetResponse   func(data *model.UserDataPublic)
	afterToProtoGetResponseCounter  uint64
	beforeToProtoGetResponseCounter uint64
	ToProtoGetResponseMock          mServiceConverterMockToProtoGetResponse

	funcToProtoPublicUser          func(data *generated.UpdateRequest) (pp1 *generated.PublicUser)
	funcToProtoPublicUserOrigin    string
	inspectFuncToProtoPublicUser   func(data *generated.UpdateRequest)
	afterToProtoPublicUserCounter  uint64
	beforeToProtoPublicUserCounter uint64
	ToProtoPublicUserMock          mServiceConverterMockToProtoPublicUser

	funcToProtoUserDataPrivate          func(data *generated.CreateRequest) (pp1 *generated.PrivateUser)
	funcToProtoUserDataPrivateOrigin    string
	inspectFuncToProtoUserDataPrivate   func(data *generated.CreateRequest)
	afterToProtoUserDataPrivateCounter  uint64
	beforeToProtoUserDataPrivateCounter uint64
	ToProtoUserDataPrivateMock          mServiceConverterMockToProtoUserDataPrivate

	funcToProtoUserDataPublic          func(src *model.UserDataPublic) (pp1 *generated.PublicUser)
	funcToProtoUserDataPublicOrigin    string
	inspectFuncToProtoUserDataPublic   func(src *model.UserDataPublic)
	afterToProtoUserDataPublicCounter  uint64
	beforeToProtoUserDataPublicCounter uint64
	ToProtoUserDataPublicMock          mServiceConverterMockToProtoUserDataPublic

	funcToServiceUserDataPrivate          func(src *generated.PrivateUser) (up1 *model.UserDataPrivate)
	funcToServiceUserDataPrivateOrigin    string
	inspectFuncToServiceUserDataPrivate   func(src *generated.PrivateUser)
	afterToServiceUserDataPrivateCounter  uint64
	beforeToServiceUserDataPrivateCounter uint64
	ToServiceUserDataPrivateMock          mServiceConverterMockToServiceUserDataPrivate

	funcToServiceUserDataPublic          func(src *generated.PublicUser) (up1 *model.UserDataPublic)
	funcToServiceUserDataPublicOrigin    string
	inspectFuncToServiceUserDataPublic   func(src *generated.PublicUser)
	afterToServiceUserDataPublicCounter  uint64
	beforeToServiceUserDataPublicCounter uint64
	ToServiceUserDataPublicMock          mServiceConverterMockToServiceUserDataPublic
}

// NewServiceConverterMock returns a mock for mm_service.ServiceConverter
func NewServiceConverterMock(t minimock.Tester) *ServiceConverterMock {
	m := &ServiceConverterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ToProtoGetResponseMock = mServiceConverterMockToProtoGetResponse{mock: m}
	m.ToProtoGetResponseMock.callArgs = []*ServiceConverterMockToProtoGetResponseParams{}

	m.ToProtoPublicUserMock = mServiceConverterMockToProtoPublicUser{mock: m}
	m.ToProtoPublicUserMock.callArgs = []*ServiceConverterMockToProtoPublicUserParams{}

	m.ToProtoUserDataPrivateMock = mServiceConverterMockToProtoUserDataPrivate{mock: m}
	m.ToProtoUserDataPrivateMock.callArgs = []*ServiceConverterMockToProtoUserDataPrivateParams{}

	m.ToProtoUserDataPublicMock = mServiceConverterMockToProtoUserDataPublic{mock: m}
	m.ToProtoUserDataPublicMock.callArgs = []*ServiceConverterMockToProtoUserDataPublicParams{}

	m.ToServiceUserDataPrivateMock = mServiceConverterMockToServiceUserDataPrivate{mock: m}
	m.ToServiceUserDataPrivateMock.callArgs = []*ServiceConverterMockToServiceUserDataPrivateParams{}

	m.ToServiceUserDataPublicMock = mServiceConverterMockToServiceUserDataPublic{mock: m}
	m.ToServiceUserDataPublicMock.callArgs = []*ServiceConverterMockToServiceUserDataPublicParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceConverterMockToProtoGetResponse struct {
	optional           bool
	mock               *ServiceConverterMock
	defaultExpectation *ServiceConverterMockToProtoGetResponseExpectation
	expectations       []*ServiceConverterMockToProtoGetResponseExpectation

	callArgs []*ServiceConverterMockToProtoGetResponseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceConverterMockToProtoGetResponseExpectation specifies expectation struct of the ServiceConverter.ToProtoGetResponse
type ServiceConverterMockToProtoGetResponseExpectation struct {
	mock               *ServiceConverterMock
	params             *ServiceConverterMockToProtoGetResponseParams
	paramPtrs          *ServiceConverterMockToProtoGetResponseParamPtrs
	expectationOrigins ServiceConverterMockToProtoGetResponseExpectationOrigins
	results            *ServiceConverterMockToProtoGetResponseResults
	returnOrigin       string
	Counter            uint64
}

// ServiceConverterMockToProtoGetResponseParams contains parameters of the ServiceConverter.ToProtoGetResponse
type ServiceConverterMockToProtoGetResponseParams struct {
	data *model.UserDataPublic
}

// ServiceConverterMockToProtoGetResponseParamPtrs contains pointers to parameters of the ServiceConverter.ToProtoGetResponse
type ServiceConverterMockToProtoGetResponseParamPtrs struct {
	data **model.UserDataPublic
}

// ServiceConverterMockToProtoGetResponseResults contains results of the ServiceConverter.ToProtoGetResponse
type ServiceConverterMockToProtoGetResponseResults struct {
	gp1 *generated.GetResponse
}

// ServiceConverterMockToProtoGetResponseOrigins contains origins of expectations of the ServiceConverter.ToProtoGetResponse
type ServiceConverterMockToProtoGetResponseExpectationOrigins struct {
	origin     string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Optional() *mServiceConverterMockToProtoGetResponse {
	mmToProtoGetResponse.optional = true
	return mmToProtoGetResponse
}

// Expect sets up expected params for ServiceConverter.ToProtoGetResponse
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Expect(data *model.UserDataPublic) *mServiceConverterMockToProtoGetResponse {
	if mmToProtoGetResponse.mock.funcToProtoGetResponse != nil {
		mmToProtoGetResponse.mock.t.Fatalf("ServiceConverterMock.ToProtoGetResponse mock is already set by Set")
	}

	if mmToProtoGetResponse.defaultExpectation == nil {
		mmToProtoGetResponse.defaultExpectation = &ServiceConverterMockToProtoGetResponseExpectation{}
	}

	if mmToProtoGetResponse.defaultExpectation.paramPtrs != nil {
		mmToProtoGetResponse.mock.t.Fatalf("ServiceConverterMock.ToProtoGetResponse mock is already set by ExpectParams functions")
	}

	mmToProtoGetResponse.defaultExpectation.params = &ServiceConverterMockToProtoGetResponseParams{data}
	mmToProtoGetResponse.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToProtoGetResponse.expectations {
		if minimock.Equal(e.params, mmToProtoGetResponse.defaultExpectation.params) {
			mmToProtoGetResponse.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToProtoGetResponse.defaultExpectation.params)
		}
	}

	return mmToProtoGetResponse
}

// ExpectDataParam1 sets up expected param data for ServiceConverter.ToProtoGetResponse
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) ExpectDataParam1(data *model.UserDataPublic) *mServiceConverterMockToProtoGetResponse {
	if mmToProtoGetResponse.mock.funcToProtoGetResponse != nil {
		mmToProtoGetResponse.mock.t.Fatalf("ServiceConverterMock.ToProtoGetResponse mock is already set by Set")
	}

	if mmToProtoGetResponse.defaultExpectation == nil {
		mmToProtoGetResponse.defaultExpectation = &ServiceConverterMockToProtoGetResponseExpectation{}
	}

	if mmToProtoGetResponse.defaultExpectation.params != nil {
		mmToProtoGetResponse.mock.t.Fatalf("ServiceConverterMock.ToProtoGetResponse mock is already set by Expect")
	}

	if mmToProtoGetResponse.defaultExpectation.paramPtrs == nil {
		mmToProtoGetResponse.defaultExpectation.paramPtrs = &ServiceConverterMockToProtoGetResponseParamPtrs{}
	}
	mmToProtoGetResponse.defaultExpectation.paramPtrs.data = &data
	mmToProtoGetResponse.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmToProtoGetResponse
}

// Inspect accepts an inspector function that has same arguments as the ServiceConverter.ToProtoGetResponse
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Inspect(f func(data *model.UserDataPublic)) *mServiceConverterMockToProtoGetResponse {
	if mmToProtoGetResponse.mock.inspectFuncToProtoGetResponse != nil {
		mmToProtoGetResponse.mock.t.Fatalf("Inspect function is already set for ServiceConverterMock.ToProtoGetResponse")
	}

	mmToProtoGetResponse.mock.inspectFuncToProtoGetResponse = f

	return mmToProtoGetResponse
}

// Return sets up results that will be returned by ServiceConverter.ToProtoGetResponse
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Return(gp1 *generated.GetResponse) *ServiceConverterMock {
	if mmToProtoGetResponse.mock.funcToProtoGetResponse != nil {
		mmToProtoGetResponse.mock.t.Fatalf("ServiceConverterMock.ToProtoGetResponse mock is already set by Set")
	}

	if mmToProtoGetResponse.defaultExpectation == nil {
		mmToProtoGetResponse.defaultExpectation = &ServiceConverterMockToProtoGetResponseExpectation{mock: mmToProtoGetResponse.mock}
	}
	mmToProtoGetResponse.defaultExpectation.results = &ServiceConverterMockToProtoGetResponseResults{gp1}
	mmToProtoGetResponse.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToProtoGetResponse.mock
}

// Set uses given function f to mock the ServiceConverter.ToProtoGetResponse method
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Set(f func(data *model.UserDataPublic) (gp1 *generated.GetResponse)) *ServiceConverterMock {
	if mmToProtoGetResponse.defaultExpectation != nil {
		mmToProtoGetResponse.mock.t.Fatalf("Default expectation is already set for the ServiceConverter.ToProtoGetResponse method")
	}

	if len(mmToProtoGetResponse.expectations) > 0 {
		mmToProtoGetResponse.mock.t.Fatalf("Some expectations are already set for the ServiceConverter.ToProtoGetResponse method")
	}

	mmToProtoGetResponse.mock.funcToProtoGetResponse = f
	mmToProtoGetResponse.mock.funcToProtoGetResponseOrigin = minimock.CallerInfo(1)
	return mmToProtoGetResponse.mock
}

// When sets expectation for the ServiceConverter.ToProtoGetResponse which will trigger the result defined by the following
// Then helper
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) When(data *model.UserDataPublic) *ServiceConverterMockToProtoGetResponseExpectation {
	if mmToProtoGetResponse.mock.funcToProtoGetResponse != nil {
		mmToProtoGetResponse.mock.t.Fatalf("ServiceConverterMock.ToProtoGetResponse mock is already set by Set")
	}

	expectation := &ServiceConverterMockToProtoGetResponseExpectation{
		mock:               mmToProtoGetResponse.mock,
		params:             &ServiceConverterMockToProtoGetResponseParams{data},
		expectationOrigins: ServiceConverterMockToProtoGetResponseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToProtoGetResponse.expectations = append(mmToProtoGetResponse.expectations, expectation)
	return expectation
}

// Then sets up ServiceConverter.ToProtoGetResponse return parameters for the expectation previously defined by the When method
func (e *ServiceConverterMockToProtoGetResponseExpectation) Then(gp1 *generated.GetResponse) *ServiceConverterMock {
	e.results = &ServiceConverterMockToProtoGetResponseResults{gp1}
	return e.mock
}

// Times sets number of times ServiceConverter.ToProtoGetResponse should be invoked
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Times(n uint64) *mServiceConverterMockToProtoGetResponse {
	if n == 0 {
		mmToProtoGetResponse.mock.t.Fatalf("Times of ServiceConverterMock.ToProtoGetResponse mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToProtoGetResponse.expectedInvocations, n)
	mmToProtoGetResponse.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToProtoGetResponse
}

func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) invocationsDone() bool {
	if len(mmToProtoGetResponse.expectations) == 0 && mmToProtoGetResponse.defaultExpectation == nil && mmToProtoGetResponse.mock.funcToProtoGetResponse == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToProtoGetResponse.mock.afterToProtoGetResponseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToProtoGetResponse.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToProtoGetResponse implements mm_service.ServiceConverter
func (mmToProtoGetResponse *ServiceConverterMock) ToProtoGetResponse(data *model.UserDataPublic) (gp1 *generated.GetResponse) {
	mm_atomic.AddUint64(&mmToProtoGetResponse.beforeToProtoGetResponseCounter, 1)
	defer mm_atomic.AddUint64(&mmToProtoGetResponse.afterToProtoGetResponseCounter, 1)

	mmToProtoGetResponse.t.Helper()

	if mmToProtoGetResponse.inspectFuncToProtoGetResponse != nil {
		mmToProtoGetResponse.inspectFuncToProtoGetResponse(data)
	}

	mm_params := ServiceConverterMockToProtoGetResponseParams{data}

	// Record call args
	mmToProtoGetResponse.ToProtoGetResponseMock.mutex.Lock()
	mmToProtoGetResponse.ToProtoGetResponseMock.callArgs = append(mmToProtoGetResponse.ToProtoGetResponseMock.callArgs, &mm_params)
	mmToProtoGetResponse.ToProtoGetResponseMock.mutex.Unlock()

	for _, e := range mmToProtoGetResponse.ToProtoGetResponseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation.Counter, 1)
		mm_want := mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation.params
		mm_want_ptrs := mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation.paramPtrs

		mm_got := ServiceConverterMockToProtoGetResponseParams{data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmToProtoGetResponse.t.Errorf("ServiceConverterMock.ToProtoGetResponse got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToProtoGetResponse.t.Errorf("ServiceConverterMock.ToProtoGetResponse got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToProtoGetResponse.ToProtoGetResponseMock.defaultExpectation.results
		if mm_results == nil {
			mmToProtoGetResponse.t.Fatal("No results are set for the ServiceConverterMock.ToProtoGetResponse")
		}
		return (*mm_results).gp1
	}
	if mmToProtoGetResponse.funcToProtoGetResponse != nil {
		return mmToProtoGetResponse.funcToProtoGetResponse(data)
	}
	mmToProtoGetResponse.t.Fatalf("Unexpected call to ServiceConverterMock.ToProtoGetResponse. %v", data)
	return
}

// ToProtoGetResponseAfterCounter returns a count of finished ServiceConverterMock.ToProtoGetResponse invocations
func (mmToProtoGetResponse *ServiceConverterMock) ToProtoGetResponseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoGetResponse.afterToProtoGetResponseCounter)
}

// ToProtoGetResponseBeforeCounter returns a count of ServiceConverterMock.ToProtoGetResponse invocations
func (mmToProtoGetResponse *ServiceConverterMock) ToProtoGetResponseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoGetResponse.beforeToProtoGetResponseCounter)
}

// Calls returns a list of arguments used in each call to ServiceConverterMock.ToProtoGetResponse.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToProtoGetResponse *mServiceConverterMockToProtoGetResponse) Calls() []*ServiceConverterMockToProtoGetResponseParams {
	mmToProtoGetResponse.mutex.RLock()

	argCopy := make([]*ServiceConverterMockToProtoGetResponseParams, len(mmToProtoGetResponse.callArgs))
	copy(argCopy, mmToProtoGetResponse.callArgs)

	mmToProtoGetResponse.mutex.RUnlock()

	return argCopy
}

// MinimockToProtoGetResponseDone returns true if the count of the ToProtoGetResponse invocations corresponds
// the number of defined expectations
func (m *ServiceConverterMock) MinimockToProtoGetResponseDone() bool {
	if m.ToProtoGetResponseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToProtoGetResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToProtoGetResponseMock.invocationsDone()
}

// MinimockToProtoGetResponseInspect logs each unmet expectation
func (m *ServiceConverterMock) MinimockToProtoGetResponseInspect() {
	for _, e := range m.ToProtoGetResponseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoGetResponse at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToProtoGetResponseCounter := mm_atomic.LoadUint64(&m.afterToProtoGetResponseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToProtoGetResponseMock.defaultExpectation != nil && afterToProtoGetResponseCounter < 1 {
		if m.ToProtoGetResponseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoGetResponse at\n%s", m.ToProtoGetResponseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoGetResponse at\n%s with params: %#v", m.ToProtoGetResponseMock.defaultExpectation.expectationOrigins.origin, *m.ToProtoGetResponseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToProtoGetResponse != nil && afterToProtoGetResponseCounter < 1 {
		m.t.Errorf("Expected call to ServiceConverterMock.ToProtoGetResponse at\n%s", m.funcToProtoGetResponseOrigin)
	}

	if !m.ToProtoGetResponseMock.invocationsDone() && afterToProtoGetResponseCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceConverterMock.ToProtoGetResponse at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToProtoGetResponseMock.expectedInvocations), m.ToProtoGetResponseMock.expectedInvocationsOrigin, afterToProtoGetResponseCounter)
	}
}

type mServiceConverterMockToProtoPublicUser struct {
	optional           bool
	mock               *ServiceConverterMock
	defaultExpectation *ServiceConverterMockToProtoPublicUserExpectation
	expectations       []*ServiceConverterMockToProtoPublicUserExpectation

	callArgs []*ServiceConverterMockToProtoPublicUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceConverterMockToProtoPublicUserExpectation specifies expectation struct of the ServiceConverter.ToProtoPublicUser
type ServiceConverterMockToProtoPublicUserExpectation struct {
	mock               *ServiceConverterMock
	params             *ServiceConverterMockToProtoPublicUserParams
	paramPtrs          *ServiceConverterMockToProtoPublicUserParamPtrs
	expectationOrigins ServiceConverterMockToProtoPublicUserExpectationOrigins
	results            *ServiceConverterMockToProtoPublicUserResults
	returnOrigin       string
	Counter            uint64
}

// ServiceConverterMockToProtoPublicUserParams contains parameters of the ServiceConverter.ToProtoPublicUser
type ServiceConverterMockToProtoPublicUserParams struct {
	data *generated.UpdateRequest
}

// ServiceConverterMockToProtoPublicUserParamPtrs contains pointers to parameters of the ServiceConverter.ToProtoPublicUser
type ServiceConverterMockToProtoPublicUserParamPtrs struct {
	data **generated.UpdateRequest
}

// ServiceConverterMockToProtoPublicUserResults contains results of the ServiceConverter.ToProtoPublicUser
type ServiceConverterMockToProtoPublicUserResults struct {
	pp1 *generated.PublicUser
}

// ServiceConverterMockToProtoPublicUserOrigins contains origins of expectations of the ServiceConverter.ToProtoPublicUser
type ServiceConverterMockToProtoPublicUserExpectationOrigins struct {
	origin     string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Optional() *mServiceConverterMockToProtoPublicUser {
	mmToProtoPublicUser.optional = true
	return mmToProtoPublicUser
}

// Expect sets up expected params for ServiceConverter.ToProtoPublicUser
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Expect(data *generated.UpdateRequest) *mServiceConverterMockToProtoPublicUser {
	if mmToProtoPublicUser.mock.funcToProtoPublicUser != nil {
		mmToProtoPublicUser.mock.t.Fatalf("ServiceConverterMock.ToProtoPublicUser mock is already set by Set")
	}

	if mmToProtoPublicUser.defaultExpectation == nil {
		mmToProtoPublicUser.defaultExpectation = &ServiceConverterMockToProtoPublicUserExpectation{}
	}

	if mmToProtoPublicUser.defaultExpectation.paramPtrs != nil {
		mmToProtoPublicUser.mock.t.Fatalf("ServiceConverterMock.ToProtoPublicUser mock is already set by ExpectParams functions")
	}

	mmToProtoPublicUser.defaultExpectation.params = &ServiceConverterMockToProtoPublicUserParams{data}
	mmToProtoPublicUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToProtoPublicUser.expectations {
		if minimock.Equal(e.params, mmToProtoPublicUser.defaultExpectation.params) {
			mmToProtoPublicUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToProtoPublicUser.defaultExpectation.params)
		}
	}

	return mmToProtoPublicUser
}

// ExpectDataParam1 sets up expected param data for ServiceConverter.ToProtoPublicUser
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) ExpectDataParam1(data *generated.UpdateRequest) *mServiceConverterMockToProtoPublicUser {
	if mmToProtoPublicUser.mock.funcToProtoPublicUser != nil {
		mmToProtoPublicUser.mock.t.Fatalf("ServiceConverterMock.ToProtoPublicUser mock is already set by Set")
	}

	if mmToProtoPublicUser.defaultExpectation == nil {
		mmToProtoPublicUser.defaultExpectation = &ServiceConverterMockToProtoPublicUserExpectation{}
	}

	if mmToProtoPublicUser.defaultExpectation.params != nil {
		mmToProtoPublicUser.mock.t.Fatalf("ServiceConverterMock.ToProtoPublicUser mock is already set by Expect")
	}

	if mmToProtoPublicUser.defaultExpectation.paramPtrs == nil {
		mmToProtoPublicUser.defaultExpectation.paramPtrs = &ServiceConverterMockToProtoPublicUserParamPtrs{}
	}
	mmToProtoPublicUser.defaultExpectation.paramPtrs.data = &data
	mmToProtoPublicUser.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmToProtoPublicUser
}

// Inspect accepts an inspector function that has same arguments as the ServiceConverter.ToProtoPublicUser
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Inspect(f func(data *generated.UpdateRequest)) *mServiceConverterMockToProtoPublicUser {
	if mmToProtoPublicUser.mock.inspectFuncToProtoPublicUser != nil {
		mmToProtoPublicUser.mock.t.Fatalf("Inspect function is already set for ServiceConverterMock.ToProtoPublicUser")
	}

	mmToProtoPublicUser.mock.inspectFuncToProtoPublicUser = f

	return mmToProtoPublicUser
}

// Return sets up results that will be returned by ServiceConverter.ToProtoPublicUser
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Return(pp1 *generated.PublicUser) *ServiceConverterMock {
	if mmToProtoPublicUser.mock.funcToProtoPublicUser != nil {
		mmToProtoPublicUser.mock.t.Fatalf("ServiceConverterMock.ToProtoPublicUser mock is already set by Set")
	}

	if mmToProtoPublicUser.defaultExpectation == nil {
		mmToProtoPublicUser.defaultExpectation = &ServiceConverterMockToProtoPublicUserExpectation{mock: mmToProtoPublicUser.mock}
	}
	mmToProtoPublicUser.defaultExpectation.results = &ServiceConverterMockToProtoPublicUserResults{pp1}
	mmToProtoPublicUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToProtoPublicUser.mock
}

// Set uses given function f to mock the ServiceConverter.ToProtoPublicUser method
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Set(f func(data *generated.UpdateRequest) (pp1 *generated.PublicUser)) *ServiceConverterMock {
	if mmToProtoPublicUser.defaultExpectation != nil {
		mmToProtoPublicUser.mock.t.Fatalf("Default expectation is already set for the ServiceConverter.ToProtoPublicUser method")
	}

	if len(mmToProtoPublicUser.expectations) > 0 {
		mmToProtoPublicUser.mock.t.Fatalf("Some expectations are already set for the ServiceConverter.ToProtoPublicUser method")
	}

	mmToProtoPublicUser.mock.funcToProtoPublicUser = f
	mmToProtoPublicUser.mock.funcToProtoPublicUserOrigin = minimock.CallerInfo(1)
	return mmToProtoPublicUser.mock
}

// When sets expectation for the ServiceConverter.ToProtoPublicUser which will trigger the result defined by the following
// Then helper
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) When(data *generated.UpdateRequest) *ServiceConverterMockToProtoPublicUserExpectation {
	if mmToProtoPublicUser.mock.funcToProtoPublicUser != nil {
		mmToProtoPublicUser.mock.t.Fatalf("ServiceConverterMock.ToProtoPublicUser mock is already set by Set")
	}

	expectation := &ServiceConverterMockToProtoPublicUserExpectation{
		mock:               mmToProtoPublicUser.mock,
		params:             &ServiceConverterMockToProtoPublicUserParams{data},
		expectationOrigins: ServiceConverterMockToProtoPublicUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToProtoPublicUser.expectations = append(mmToProtoPublicUser.expectations, expectation)
	return expectation
}

// Then sets up ServiceConverter.ToProtoPublicUser return parameters for the expectation previously defined by the When method
func (e *ServiceConverterMockToProtoPublicUserExpectation) Then(pp1 *generated.PublicUser) *ServiceConverterMock {
	e.results = &ServiceConverterMockToProtoPublicUserResults{pp1}
	return e.mock
}

// Times sets number of times ServiceConverter.ToProtoPublicUser should be invoked
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Times(n uint64) *mServiceConverterMockToProtoPublicUser {
	if n == 0 {
		mmToProtoPublicUser.mock.t.Fatalf("Times of ServiceConverterMock.ToProtoPublicUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToProtoPublicUser.expectedInvocations, n)
	mmToProtoPublicUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToProtoPublicUser
}

func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) invocationsDone() bool {
	if len(mmToProtoPublicUser.expectations) == 0 && mmToProtoPublicUser.defaultExpectation == nil && mmToProtoPublicUser.mock.funcToProtoPublicUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToProtoPublicUser.mock.afterToProtoPublicUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToProtoPublicUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToProtoPublicUser implements mm_service.ServiceConverter
func (mmToProtoPublicUser *ServiceConverterMock) ToProtoPublicUser(data *generated.UpdateRequest) (pp1 *generated.PublicUser) {
	mm_atomic.AddUint64(&mmToProtoPublicUser.beforeToProtoPublicUserCounter, 1)
	defer mm_atomic.AddUint64(&mmToProtoPublicUser.afterToProtoPublicUserCounter, 1)

	mmToProtoPublicUser.t.Helper()

	if mmToProtoPublicUser.inspectFuncToProtoPublicUser != nil {
		mmToProtoPublicUser.inspectFuncToProtoPublicUser(data)
	}

	mm_params := ServiceConverterMockToProtoPublicUserParams{data}

	// Record call args
	mmToProtoPublicUser.ToProtoPublicUserMock.mutex.Lock()
	mmToProtoPublicUser.ToProtoPublicUserMock.callArgs = append(mmToProtoPublicUser.ToProtoPublicUserMock.callArgs, &mm_params)
	mmToProtoPublicUser.ToProtoPublicUserMock.mutex.Unlock()

	for _, e := range mmToProtoPublicUser.ToProtoPublicUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1
		}
	}

	if mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation.Counter, 1)
		mm_want := mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation.params
		mm_want_ptrs := mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation.paramPtrs

		mm_got := ServiceConverterMockToProtoPublicUserParams{data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmToProtoPublicUser.t.Errorf("ServiceConverterMock.ToProtoPublicUser got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToProtoPublicUser.t.Errorf("ServiceConverterMock.ToProtoPublicUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToProtoPublicUser.ToProtoPublicUserMock.defaultExpectation.results
		if mm_results == nil {
			mmToProtoPublicUser.t.Fatal("No results are set for the ServiceConverterMock.ToProtoPublicUser")
		}
		return (*mm_results).pp1
	}
	if mmToProtoPublicUser.funcToProtoPublicUser != nil {
		return mmToProtoPublicUser.funcToProtoPublicUser(data)
	}
	mmToProtoPublicUser.t.Fatalf("Unexpected call to ServiceConverterMock.ToProtoPublicUser. %v", data)
	return
}

// ToProtoPublicUserAfterCounter returns a count of finished ServiceConverterMock.ToProtoPublicUser invocations
func (mmToProtoPublicUser *ServiceConverterMock) ToProtoPublicUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoPublicUser.afterToProtoPublicUserCounter)
}

// ToProtoPublicUserBeforeCounter returns a count of ServiceConverterMock.ToProtoPublicUser invocations
func (mmToProtoPublicUser *ServiceConverterMock) ToProtoPublicUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoPublicUser.beforeToProtoPublicUserCounter)
}

// Calls returns a list of arguments used in each call to ServiceConverterMock.ToProtoPublicUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToProtoPublicUser *mServiceConverterMockToProtoPublicUser) Calls() []*ServiceConverterMockToProtoPublicUserParams {
	mmToProtoPublicUser.mutex.RLock()

	argCopy := make([]*ServiceConverterMockToProtoPublicUserParams, len(mmToProtoPublicUser.callArgs))
	copy(argCopy, mmToProtoPublicUser.callArgs)

	mmToProtoPublicUser.mutex.RUnlock()

	return argCopy
}

// MinimockToProtoPublicUserDone returns true if the count of the ToProtoPublicUser invocations corresponds
// the number of defined expectations
func (m *ServiceConverterMock) MinimockToProtoPublicUserDone() bool {
	if m.ToProtoPublicUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToProtoPublicUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToProtoPublicUserMock.invocationsDone()
}

// MinimockToProtoPublicUserInspect logs each unmet expectation
func (m *ServiceConverterMock) MinimockToProtoPublicUserInspect() {
	for _, e := range m.ToProtoPublicUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoPublicUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToProtoPublicUserCounter := mm_atomic.LoadUint64(&m.afterToProtoPublicUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToProtoPublicUserMock.defaultExpectation != nil && afterToProtoPublicUserCounter < 1 {
		if m.ToProtoPublicUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoPublicUser at\n%s", m.ToProtoPublicUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoPublicUser at\n%s with params: %#v", m.ToProtoPublicUserMock.defaultExpectation.expectationOrigins.origin, *m.ToProtoPublicUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToProtoPublicUser != nil && afterToProtoPublicUserCounter < 1 {
		m.t.Errorf("Expected call to ServiceConverterMock.ToProtoPublicUser at\n%s", m.funcToProtoPublicUserOrigin)
	}

	if !m.ToProtoPublicUserMock.invocationsDone() && afterToProtoPublicUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceConverterMock.ToProtoPublicUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToProtoPublicUserMock.expectedInvocations), m.ToProtoPublicUserMock.expectedInvocationsOrigin, afterToProtoPublicUserCounter)
	}
}

type mServiceConverterMockToProtoUserDataPrivate struct {
	optional           bool
	mock               *ServiceConverterMock
	defaultExpectation *ServiceConverterMockToProtoUserDataPrivateExpectation
	expectations       []*ServiceConverterMockToProtoUserDataPrivateExpectation

	callArgs []*ServiceConverterMockToProtoUserDataPrivateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceConverterMockToProtoUserDataPrivateExpectation specifies expectation struct of the ServiceConverter.ToProtoUserDataPrivate
type ServiceConverterMockToProtoUserDataPrivateExpectation struct {
	mock               *ServiceConverterMock
	params             *ServiceConverterMockToProtoUserDataPrivateParams
	paramPtrs          *ServiceConverterMockToProtoUserDataPrivateParamPtrs
	expectationOrigins ServiceConverterMockToProtoUserDataPrivateExpectationOrigins
	results            *ServiceConverterMockToProtoUserDataPrivateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceConverterMockToProtoUserDataPrivateParams contains parameters of the ServiceConverter.ToProtoUserDataPrivate
type ServiceConverterMockToProtoUserDataPrivateParams struct {
	data *generated.CreateRequest
}

// ServiceConverterMockToProtoUserDataPrivateParamPtrs contains pointers to parameters of the ServiceConverter.ToProtoUserDataPrivate
type ServiceConverterMockToProtoUserDataPrivateParamPtrs struct {
	data **generated.CreateRequest
}

// ServiceConverterMockToProtoUserDataPrivateResults contains results of the ServiceConverter.ToProtoUserDataPrivate
type ServiceConverterMockToProtoUserDataPrivateResults struct {
	pp1 *generated.PrivateUser
}

// ServiceConverterMockToProtoUserDataPrivateOrigins contains origins of expectations of the ServiceConverter.ToProtoUserDataPrivate
type ServiceConverterMockToProtoUserDataPrivateExpectationOrigins struct {
	origin     string
	originData string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Optional() *mServiceConverterMockToProtoUserDataPrivate {
	mmToProtoUserDataPrivate.optional = true
	return mmToProtoUserDataPrivate
}

// Expect sets up expected params for ServiceConverter.ToProtoUserDataPrivate
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Expect(data *generated.CreateRequest) *mServiceConverterMockToProtoUserDataPrivate {
	if mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivate != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPrivate mock is already set by Set")
	}

	if mmToProtoUserDataPrivate.defaultExpectation == nil {
		mmToProtoUserDataPrivate.defaultExpectation = &ServiceConverterMockToProtoUserDataPrivateExpectation{}
	}

	if mmToProtoUserDataPrivate.defaultExpectation.paramPtrs != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPrivate mock is already set by ExpectParams functions")
	}

	mmToProtoUserDataPrivate.defaultExpectation.params = &ServiceConverterMockToProtoUserDataPrivateParams{data}
	mmToProtoUserDataPrivate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToProtoUserDataPrivate.expectations {
		if minimock.Equal(e.params, mmToProtoUserDataPrivate.defaultExpectation.params) {
			mmToProtoUserDataPrivate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToProtoUserDataPrivate.defaultExpectation.params)
		}
	}

	return mmToProtoUserDataPrivate
}

// ExpectDataParam1 sets up expected param data for ServiceConverter.ToProtoUserDataPrivate
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) ExpectDataParam1(data *generated.CreateRequest) *mServiceConverterMockToProtoUserDataPrivate {
	if mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivate != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPrivate mock is already set by Set")
	}

	if mmToProtoUserDataPrivate.defaultExpectation == nil {
		mmToProtoUserDataPrivate.defaultExpectation = &ServiceConverterMockToProtoUserDataPrivateExpectation{}
	}

	if mmToProtoUserDataPrivate.defaultExpectation.params != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPrivate mock is already set by Expect")
	}

	if mmToProtoUserDataPrivate.defaultExpectation.paramPtrs == nil {
		mmToProtoUserDataPrivate.defaultExpectation.paramPtrs = &ServiceConverterMockToProtoUserDataPrivateParamPtrs{}
	}
	mmToProtoUserDataPrivate.defaultExpectation.paramPtrs.data = &data
	mmToProtoUserDataPrivate.defaultExpectation.expectationOrigins.originData = minimock.CallerInfo(1)

	return mmToProtoUserDataPrivate
}

// Inspect accepts an inspector function that has same arguments as the ServiceConverter.ToProtoUserDataPrivate
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Inspect(f func(data *generated.CreateRequest)) *mServiceConverterMockToProtoUserDataPrivate {
	if mmToProtoUserDataPrivate.mock.inspectFuncToProtoUserDataPrivate != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("Inspect function is already set for ServiceConverterMock.ToProtoUserDataPrivate")
	}

	mmToProtoUserDataPrivate.mock.inspectFuncToProtoUserDataPrivate = f

	return mmToProtoUserDataPrivate
}

// Return sets up results that will be returned by ServiceConverter.ToProtoUserDataPrivate
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Return(pp1 *generated.PrivateUser) *ServiceConverterMock {
	if mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivate != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPrivate mock is already set by Set")
	}

	if mmToProtoUserDataPrivate.defaultExpectation == nil {
		mmToProtoUserDataPrivate.defaultExpectation = &ServiceConverterMockToProtoUserDataPrivateExpectation{mock: mmToProtoUserDataPrivate.mock}
	}
	mmToProtoUserDataPrivate.defaultExpectation.results = &ServiceConverterMockToProtoUserDataPrivateResults{pp1}
	mmToProtoUserDataPrivate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToProtoUserDataPrivate.mock
}

// Set uses given function f to mock the ServiceConverter.ToProtoUserDataPrivate method
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Set(f func(data *generated.CreateRequest) (pp1 *generated.PrivateUser)) *ServiceConverterMock {
	if mmToProtoUserDataPrivate.defaultExpectation != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("Default expectation is already set for the ServiceConverter.ToProtoUserDataPrivate method")
	}

	if len(mmToProtoUserDataPrivate.expectations) > 0 {
		mmToProtoUserDataPrivate.mock.t.Fatalf("Some expectations are already set for the ServiceConverter.ToProtoUserDataPrivate method")
	}

	mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivate = f
	mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivateOrigin = minimock.CallerInfo(1)
	return mmToProtoUserDataPrivate.mock
}

// When sets expectation for the ServiceConverter.ToProtoUserDataPrivate which will trigger the result defined by the following
// Then helper
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) When(data *generated.CreateRequest) *ServiceConverterMockToProtoUserDataPrivateExpectation {
	if mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivate != nil {
		mmToProtoUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPrivate mock is already set by Set")
	}

	expectation := &ServiceConverterMockToProtoUserDataPrivateExpectation{
		mock:               mmToProtoUserDataPrivate.mock,
		params:             &ServiceConverterMockToProtoUserDataPrivateParams{data},
		expectationOrigins: ServiceConverterMockToProtoUserDataPrivateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToProtoUserDataPrivate.expectations = append(mmToProtoUserDataPrivate.expectations, expectation)
	return expectation
}

// Then sets up ServiceConverter.ToProtoUserDataPrivate return parameters for the expectation previously defined by the When method
func (e *ServiceConverterMockToProtoUserDataPrivateExpectation) Then(pp1 *generated.PrivateUser) *ServiceConverterMock {
	e.results = &ServiceConverterMockToProtoUserDataPrivateResults{pp1}
	return e.mock
}

// Times sets number of times ServiceConverter.ToProtoUserDataPrivate should be invoked
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Times(n uint64) *mServiceConverterMockToProtoUserDataPrivate {
	if n == 0 {
		mmToProtoUserDataPrivate.mock.t.Fatalf("Times of ServiceConverterMock.ToProtoUserDataPrivate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToProtoUserDataPrivate.expectedInvocations, n)
	mmToProtoUserDataPrivate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToProtoUserDataPrivate
}

func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) invocationsDone() bool {
	if len(mmToProtoUserDataPrivate.expectations) == 0 && mmToProtoUserDataPrivate.defaultExpectation == nil && mmToProtoUserDataPrivate.mock.funcToProtoUserDataPrivate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToProtoUserDataPrivate.mock.afterToProtoUserDataPrivateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToProtoUserDataPrivate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToProtoUserDataPrivate implements mm_service.ServiceConverter
func (mmToProtoUserDataPrivate *ServiceConverterMock) ToProtoUserDataPrivate(data *generated.CreateRequest) (pp1 *generated.PrivateUser) {
	mm_atomic.AddUint64(&mmToProtoUserDataPrivate.beforeToProtoUserDataPrivateCounter, 1)
	defer mm_atomic.AddUint64(&mmToProtoUserDataPrivate.afterToProtoUserDataPrivateCounter, 1)

	mmToProtoUserDataPrivate.t.Helper()

	if mmToProtoUserDataPrivate.inspectFuncToProtoUserDataPrivate != nil {
		mmToProtoUserDataPrivate.inspectFuncToProtoUserDataPrivate(data)
	}

	mm_params := ServiceConverterMockToProtoUserDataPrivateParams{data}

	// Record call args
	mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.mutex.Lock()
	mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.callArgs = append(mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.callArgs, &mm_params)
	mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.mutex.Unlock()

	for _, e := range mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1
		}
	}

	if mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation.Counter, 1)
		mm_want := mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation.params
		mm_want_ptrs := mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation.paramPtrs

		mm_got := ServiceConverterMockToProtoUserDataPrivateParams{data}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.data != nil && !minimock.Equal(*mm_want_ptrs.data, mm_got.data) {
				mmToProtoUserDataPrivate.t.Errorf("ServiceConverterMock.ToProtoUserDataPrivate got unexpected parameter data, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation.expectationOrigins.originData, *mm_want_ptrs.data, mm_got.data, minimock.Diff(*mm_want_ptrs.data, mm_got.data))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToProtoUserDataPrivate.t.Errorf("ServiceConverterMock.ToProtoUserDataPrivate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToProtoUserDataPrivate.ToProtoUserDataPrivateMock.defaultExpectation.results
		if mm_results == nil {
			mmToProtoUserDataPrivate.t.Fatal("No results are set for the ServiceConverterMock.ToProtoUserDataPrivate")
		}
		return (*mm_results).pp1
	}
	if mmToProtoUserDataPrivate.funcToProtoUserDataPrivate != nil {
		return mmToProtoUserDataPrivate.funcToProtoUserDataPrivate(data)
	}
	mmToProtoUserDataPrivate.t.Fatalf("Unexpected call to ServiceConverterMock.ToProtoUserDataPrivate. %v", data)
	return
}

// ToProtoUserDataPrivateAfterCounter returns a count of finished ServiceConverterMock.ToProtoUserDataPrivate invocations
func (mmToProtoUserDataPrivate *ServiceConverterMock) ToProtoUserDataPrivateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoUserDataPrivate.afterToProtoUserDataPrivateCounter)
}

// ToProtoUserDataPrivateBeforeCounter returns a count of ServiceConverterMock.ToProtoUserDataPrivate invocations
func (mmToProtoUserDataPrivate *ServiceConverterMock) ToProtoUserDataPrivateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoUserDataPrivate.beforeToProtoUserDataPrivateCounter)
}

// Calls returns a list of arguments used in each call to ServiceConverterMock.ToProtoUserDataPrivate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToProtoUserDataPrivate *mServiceConverterMockToProtoUserDataPrivate) Calls() []*ServiceConverterMockToProtoUserDataPrivateParams {
	mmToProtoUserDataPrivate.mutex.RLock()

	argCopy := make([]*ServiceConverterMockToProtoUserDataPrivateParams, len(mmToProtoUserDataPrivate.callArgs))
	copy(argCopy, mmToProtoUserDataPrivate.callArgs)

	mmToProtoUserDataPrivate.mutex.RUnlock()

	return argCopy
}

// MinimockToProtoUserDataPrivateDone returns true if the count of the ToProtoUserDataPrivate invocations corresponds
// the number of defined expectations
func (m *ServiceConverterMock) MinimockToProtoUserDataPrivateDone() bool {
	if m.ToProtoUserDataPrivateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToProtoUserDataPrivateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToProtoUserDataPrivateMock.invocationsDone()
}

// MinimockToProtoUserDataPrivateInspect logs each unmet expectation
func (m *ServiceConverterMock) MinimockToProtoUserDataPrivateInspect() {
	for _, e := range m.ToProtoUserDataPrivateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPrivate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToProtoUserDataPrivateCounter := mm_atomic.LoadUint64(&m.afterToProtoUserDataPrivateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToProtoUserDataPrivateMock.defaultExpectation != nil && afterToProtoUserDataPrivateCounter < 1 {
		if m.ToProtoUserDataPrivateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPrivate at\n%s", m.ToProtoUserDataPrivateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPrivate at\n%s with params: %#v", m.ToProtoUserDataPrivateMock.defaultExpectation.expectationOrigins.origin, *m.ToProtoUserDataPrivateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToProtoUserDataPrivate != nil && afterToProtoUserDataPrivateCounter < 1 {
		m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPrivate at\n%s", m.funcToProtoUserDataPrivateOrigin)
	}

	if !m.ToProtoUserDataPrivateMock.invocationsDone() && afterToProtoUserDataPrivateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceConverterMock.ToProtoUserDataPrivate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToProtoUserDataPrivateMock.expectedInvocations), m.ToProtoUserDataPrivateMock.expectedInvocationsOrigin, afterToProtoUserDataPrivateCounter)
	}
}

type mServiceConverterMockToProtoUserDataPublic struct {
	optional           bool
	mock               *ServiceConverterMock
	defaultExpectation *ServiceConverterMockToProtoUserDataPublicExpectation
	expectations       []*ServiceConverterMockToProtoUserDataPublicExpectation

	callArgs []*ServiceConverterMockToProtoUserDataPublicParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceConverterMockToProtoUserDataPublicExpectation specifies expectation struct of the ServiceConverter.ToProtoUserDataPublic
type ServiceConverterMockToProtoUserDataPublicExpectation struct {
	mock               *ServiceConverterMock
	params             *ServiceConverterMockToProtoUserDataPublicParams
	paramPtrs          *ServiceConverterMockToProtoUserDataPublicParamPtrs
	expectationOrigins ServiceConverterMockToProtoUserDataPublicExpectationOrigins
	results            *ServiceConverterMockToProtoUserDataPublicResults
	returnOrigin       string
	Counter            uint64
}

// ServiceConverterMockToProtoUserDataPublicParams contains parameters of the ServiceConverter.ToProtoUserDataPublic
type ServiceConverterMockToProtoUserDataPublicParams struct {
	src *model.UserDataPublic
}

// ServiceConverterMockToProtoUserDataPublicParamPtrs contains pointers to parameters of the ServiceConverter.ToProtoUserDataPublic
type ServiceConverterMockToProtoUserDataPublicParamPtrs struct {
	src **model.UserDataPublic
}

// ServiceConverterMockToProtoUserDataPublicResults contains results of the ServiceConverter.ToProtoUserDataPublic
type ServiceConverterMockToProtoUserDataPublicResults struct {
	pp1 *generated.PublicUser
}

// ServiceConverterMockToProtoUserDataPublicOrigins contains origins of expectations of the ServiceConverter.ToProtoUserDataPublic
type ServiceConverterMockToProtoUserDataPublicExpectationOrigins struct {
	origin    string
	originSrc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Optional() *mServiceConverterMockToProtoUserDataPublic {
	mmToProtoUserDataPublic.optional = true
	return mmToProtoUserDataPublic
}

// Expect sets up expected params for ServiceConverter.ToProtoUserDataPublic
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Expect(src *model.UserDataPublic) *mServiceConverterMockToProtoUserDataPublic {
	if mmToProtoUserDataPublic.mock.funcToProtoUserDataPublic != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPublic mock is already set by Set")
	}

	if mmToProtoUserDataPublic.defaultExpectation == nil {
		mmToProtoUserDataPublic.defaultExpectation = &ServiceConverterMockToProtoUserDataPublicExpectation{}
	}

	if mmToProtoUserDataPublic.defaultExpectation.paramPtrs != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPublic mock is already set by ExpectParams functions")
	}

	mmToProtoUserDataPublic.defaultExpectation.params = &ServiceConverterMockToProtoUserDataPublicParams{src}
	mmToProtoUserDataPublic.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToProtoUserDataPublic.expectations {
		if minimock.Equal(e.params, mmToProtoUserDataPublic.defaultExpectation.params) {
			mmToProtoUserDataPublic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToProtoUserDataPublic.defaultExpectation.params)
		}
	}

	return mmToProtoUserDataPublic
}

// ExpectSrcParam1 sets up expected param src for ServiceConverter.ToProtoUserDataPublic
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) ExpectSrcParam1(src *model.UserDataPublic) *mServiceConverterMockToProtoUserDataPublic {
	if mmToProtoUserDataPublic.mock.funcToProtoUserDataPublic != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPublic mock is already set by Set")
	}

	if mmToProtoUserDataPublic.defaultExpectation == nil {
		mmToProtoUserDataPublic.defaultExpectation = &ServiceConverterMockToProtoUserDataPublicExpectation{}
	}

	if mmToProtoUserDataPublic.defaultExpectation.params != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPublic mock is already set by Expect")
	}

	if mmToProtoUserDataPublic.defaultExpectation.paramPtrs == nil {
		mmToProtoUserDataPublic.defaultExpectation.paramPtrs = &ServiceConverterMockToProtoUserDataPublicParamPtrs{}
	}
	mmToProtoUserDataPublic.defaultExpectation.paramPtrs.src = &src
	mmToProtoUserDataPublic.defaultExpectation.expectationOrigins.originSrc = minimock.CallerInfo(1)

	return mmToProtoUserDataPublic
}

// Inspect accepts an inspector function that has same arguments as the ServiceConverter.ToProtoUserDataPublic
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Inspect(f func(src *model.UserDataPublic)) *mServiceConverterMockToProtoUserDataPublic {
	if mmToProtoUserDataPublic.mock.inspectFuncToProtoUserDataPublic != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("Inspect function is already set for ServiceConverterMock.ToProtoUserDataPublic")
	}

	mmToProtoUserDataPublic.mock.inspectFuncToProtoUserDataPublic = f

	return mmToProtoUserDataPublic
}

// Return sets up results that will be returned by ServiceConverter.ToProtoUserDataPublic
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Return(pp1 *generated.PublicUser) *ServiceConverterMock {
	if mmToProtoUserDataPublic.mock.funcToProtoUserDataPublic != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPublic mock is already set by Set")
	}

	if mmToProtoUserDataPublic.defaultExpectation == nil {
		mmToProtoUserDataPublic.defaultExpectation = &ServiceConverterMockToProtoUserDataPublicExpectation{mock: mmToProtoUserDataPublic.mock}
	}
	mmToProtoUserDataPublic.defaultExpectation.results = &ServiceConverterMockToProtoUserDataPublicResults{pp1}
	mmToProtoUserDataPublic.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToProtoUserDataPublic.mock
}

// Set uses given function f to mock the ServiceConverter.ToProtoUserDataPublic method
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Set(f func(src *model.UserDataPublic) (pp1 *generated.PublicUser)) *ServiceConverterMock {
	if mmToProtoUserDataPublic.defaultExpectation != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("Default expectation is already set for the ServiceConverter.ToProtoUserDataPublic method")
	}

	if len(mmToProtoUserDataPublic.expectations) > 0 {
		mmToProtoUserDataPublic.mock.t.Fatalf("Some expectations are already set for the ServiceConverter.ToProtoUserDataPublic method")
	}

	mmToProtoUserDataPublic.mock.funcToProtoUserDataPublic = f
	mmToProtoUserDataPublic.mock.funcToProtoUserDataPublicOrigin = minimock.CallerInfo(1)
	return mmToProtoUserDataPublic.mock
}

// When sets expectation for the ServiceConverter.ToProtoUserDataPublic which will trigger the result defined by the following
// Then helper
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) When(src *model.UserDataPublic) *ServiceConverterMockToProtoUserDataPublicExpectation {
	if mmToProtoUserDataPublic.mock.funcToProtoUserDataPublic != nil {
		mmToProtoUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToProtoUserDataPublic mock is already set by Set")
	}

	expectation := &ServiceConverterMockToProtoUserDataPublicExpectation{
		mock:               mmToProtoUserDataPublic.mock,
		params:             &ServiceConverterMockToProtoUserDataPublicParams{src},
		expectationOrigins: ServiceConverterMockToProtoUserDataPublicExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToProtoUserDataPublic.expectations = append(mmToProtoUserDataPublic.expectations, expectation)
	return expectation
}

// Then sets up ServiceConverter.ToProtoUserDataPublic return parameters for the expectation previously defined by the When method
func (e *ServiceConverterMockToProtoUserDataPublicExpectation) Then(pp1 *generated.PublicUser) *ServiceConverterMock {
	e.results = &ServiceConverterMockToProtoUserDataPublicResults{pp1}
	return e.mock
}

// Times sets number of times ServiceConverter.ToProtoUserDataPublic should be invoked
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Times(n uint64) *mServiceConverterMockToProtoUserDataPublic {
	if n == 0 {
		mmToProtoUserDataPublic.mock.t.Fatalf("Times of ServiceConverterMock.ToProtoUserDataPublic mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToProtoUserDataPublic.expectedInvocations, n)
	mmToProtoUserDataPublic.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToProtoUserDataPublic
}

func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) invocationsDone() bool {
	if len(mmToProtoUserDataPublic.expectations) == 0 && mmToProtoUserDataPublic.defaultExpectation == nil && mmToProtoUserDataPublic.mock.funcToProtoUserDataPublic == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToProtoUserDataPublic.mock.afterToProtoUserDataPublicCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToProtoUserDataPublic.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToProtoUserDataPublic implements mm_service.ServiceConverter
func (mmToProtoUserDataPublic *ServiceConverterMock) ToProtoUserDataPublic(src *model.UserDataPublic) (pp1 *generated.PublicUser) {
	mm_atomic.AddUint64(&mmToProtoUserDataPublic.beforeToProtoUserDataPublicCounter, 1)
	defer mm_atomic.AddUint64(&mmToProtoUserDataPublic.afterToProtoUserDataPublicCounter, 1)

	mmToProtoUserDataPublic.t.Helper()

	if mmToProtoUserDataPublic.inspectFuncToProtoUserDataPublic != nil {
		mmToProtoUserDataPublic.inspectFuncToProtoUserDataPublic(src)
	}

	mm_params := ServiceConverterMockToProtoUserDataPublicParams{src}

	// Record call args
	mmToProtoUserDataPublic.ToProtoUserDataPublicMock.mutex.Lock()
	mmToProtoUserDataPublic.ToProtoUserDataPublicMock.callArgs = append(mmToProtoUserDataPublic.ToProtoUserDataPublicMock.callArgs, &mm_params)
	mmToProtoUserDataPublic.ToProtoUserDataPublicMock.mutex.Unlock()

	for _, e := range mmToProtoUserDataPublic.ToProtoUserDataPublicMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1
		}
	}

	if mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation.Counter, 1)
		mm_want := mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation.params
		mm_want_ptrs := mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation.paramPtrs

		mm_got := ServiceConverterMockToProtoUserDataPublicParams{src}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.src != nil && !minimock.Equal(*mm_want_ptrs.src, mm_got.src) {
				mmToProtoUserDataPublic.t.Errorf("ServiceConverterMock.ToProtoUserDataPublic got unexpected parameter src, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation.expectationOrigins.originSrc, *mm_want_ptrs.src, mm_got.src, minimock.Diff(*mm_want_ptrs.src, mm_got.src))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToProtoUserDataPublic.t.Errorf("ServiceConverterMock.ToProtoUserDataPublic got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToProtoUserDataPublic.ToProtoUserDataPublicMock.defaultExpectation.results
		if mm_results == nil {
			mmToProtoUserDataPublic.t.Fatal("No results are set for the ServiceConverterMock.ToProtoUserDataPublic")
		}
		return (*mm_results).pp1
	}
	if mmToProtoUserDataPublic.funcToProtoUserDataPublic != nil {
		return mmToProtoUserDataPublic.funcToProtoUserDataPublic(src)
	}
	mmToProtoUserDataPublic.t.Fatalf("Unexpected call to ServiceConverterMock.ToProtoUserDataPublic. %v", src)
	return
}

// ToProtoUserDataPublicAfterCounter returns a count of finished ServiceConverterMock.ToProtoUserDataPublic invocations
func (mmToProtoUserDataPublic *ServiceConverterMock) ToProtoUserDataPublicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoUserDataPublic.afterToProtoUserDataPublicCounter)
}

// ToProtoUserDataPublicBeforeCounter returns a count of ServiceConverterMock.ToProtoUserDataPublic invocations
func (mmToProtoUserDataPublic *ServiceConverterMock) ToProtoUserDataPublicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToProtoUserDataPublic.beforeToProtoUserDataPublicCounter)
}

// Calls returns a list of arguments used in each call to ServiceConverterMock.ToProtoUserDataPublic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToProtoUserDataPublic *mServiceConverterMockToProtoUserDataPublic) Calls() []*ServiceConverterMockToProtoUserDataPublicParams {
	mmToProtoUserDataPublic.mutex.RLock()

	argCopy := make([]*ServiceConverterMockToProtoUserDataPublicParams, len(mmToProtoUserDataPublic.callArgs))
	copy(argCopy, mmToProtoUserDataPublic.callArgs)

	mmToProtoUserDataPublic.mutex.RUnlock()

	return argCopy
}

// MinimockToProtoUserDataPublicDone returns true if the count of the ToProtoUserDataPublic invocations corresponds
// the number of defined expectations
func (m *ServiceConverterMock) MinimockToProtoUserDataPublicDone() bool {
	if m.ToProtoUserDataPublicMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToProtoUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToProtoUserDataPublicMock.invocationsDone()
}

// MinimockToProtoUserDataPublicInspect logs each unmet expectation
func (m *ServiceConverterMock) MinimockToProtoUserDataPublicInspect() {
	for _, e := range m.ToProtoUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPublic at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToProtoUserDataPublicCounter := mm_atomic.LoadUint64(&m.afterToProtoUserDataPublicCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToProtoUserDataPublicMock.defaultExpectation != nil && afterToProtoUserDataPublicCounter < 1 {
		if m.ToProtoUserDataPublicMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPublic at\n%s", m.ToProtoUserDataPublicMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPublic at\n%s with params: %#v", m.ToProtoUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *m.ToProtoUserDataPublicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToProtoUserDataPublic != nil && afterToProtoUserDataPublicCounter < 1 {
		m.t.Errorf("Expected call to ServiceConverterMock.ToProtoUserDataPublic at\n%s", m.funcToProtoUserDataPublicOrigin)
	}

	if !m.ToProtoUserDataPublicMock.invocationsDone() && afterToProtoUserDataPublicCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceConverterMock.ToProtoUserDataPublic at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToProtoUserDataPublicMock.expectedInvocations), m.ToProtoUserDataPublicMock.expectedInvocationsOrigin, afterToProtoUserDataPublicCounter)
	}
}

type mServiceConverterMockToServiceUserDataPrivate struct {
	optional           bool
	mock               *ServiceConverterMock
	defaultExpectation *ServiceConverterMockToServiceUserDataPrivateExpectation
	expectations       []*ServiceConverterMockToServiceUserDataPrivateExpectation

	callArgs []*ServiceConverterMockToServiceUserDataPrivateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceConverterMockToServiceUserDataPrivateExpectation specifies expectation struct of the ServiceConverter.ToServiceUserDataPrivate
type ServiceConverterMockToServiceUserDataPrivateExpectation struct {
	mock               *ServiceConverterMock
	params             *ServiceConverterMockToServiceUserDataPrivateParams
	paramPtrs          *ServiceConverterMockToServiceUserDataPrivateParamPtrs
	expectationOrigins ServiceConverterMockToServiceUserDataPrivateExpectationOrigins
	results            *ServiceConverterMockToServiceUserDataPrivateResults
	returnOrigin       string
	Counter            uint64
}

// ServiceConverterMockToServiceUserDataPrivateParams contains parameters of the ServiceConverter.ToServiceUserDataPrivate
type ServiceConverterMockToServiceUserDataPrivateParams struct {
	src *generated.PrivateUser
}

// ServiceConverterMockToServiceUserDataPrivateParamPtrs contains pointers to parameters of the ServiceConverter.ToServiceUserDataPrivate
type ServiceConverterMockToServiceUserDataPrivateParamPtrs struct {
	src **generated.PrivateUser
}

// ServiceConverterMockToServiceUserDataPrivateResults contains results of the ServiceConverter.ToServiceUserDataPrivate
type ServiceConverterMockToServiceUserDataPrivateResults struct {
	up1 *model.UserDataPrivate
}

// ServiceConverterMockToServiceUserDataPrivateOrigins contains origins of expectations of the ServiceConverter.ToServiceUserDataPrivate
type ServiceConverterMockToServiceUserDataPrivateExpectationOrigins struct {
	origin    string
	originSrc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Optional() *mServiceConverterMockToServiceUserDataPrivate {
	mmToServiceUserDataPrivate.optional = true
	return mmToServiceUserDataPrivate
}

// Expect sets up expected params for ServiceConverter.ToServiceUserDataPrivate
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Expect(src *generated.PrivateUser) *mServiceConverterMockToServiceUserDataPrivate {
	if mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivate != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPrivate mock is already set by Set")
	}

	if mmToServiceUserDataPrivate.defaultExpectation == nil {
		mmToServiceUserDataPrivate.defaultExpectation = &ServiceConverterMockToServiceUserDataPrivateExpectation{}
	}

	if mmToServiceUserDataPrivate.defaultExpectation.paramPtrs != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPrivate mock is already set by ExpectParams functions")
	}

	mmToServiceUserDataPrivate.defaultExpectation.params = &ServiceConverterMockToServiceUserDataPrivateParams{src}
	mmToServiceUserDataPrivate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToServiceUserDataPrivate.expectations {
		if minimock.Equal(e.params, mmToServiceUserDataPrivate.defaultExpectation.params) {
			mmToServiceUserDataPrivate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToServiceUserDataPrivate.defaultExpectation.params)
		}
	}

	return mmToServiceUserDataPrivate
}

// ExpectSrcParam1 sets up expected param src for ServiceConverter.ToServiceUserDataPrivate
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) ExpectSrcParam1(src *generated.PrivateUser) *mServiceConverterMockToServiceUserDataPrivate {
	if mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivate != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPrivate mock is already set by Set")
	}

	if mmToServiceUserDataPrivate.defaultExpectation == nil {
		mmToServiceUserDataPrivate.defaultExpectation = &ServiceConverterMockToServiceUserDataPrivateExpectation{}
	}

	if mmToServiceUserDataPrivate.defaultExpectation.params != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPrivate mock is already set by Expect")
	}

	if mmToServiceUserDataPrivate.defaultExpectation.paramPtrs == nil {
		mmToServiceUserDataPrivate.defaultExpectation.paramPtrs = &ServiceConverterMockToServiceUserDataPrivateParamPtrs{}
	}
	mmToServiceUserDataPrivate.defaultExpectation.paramPtrs.src = &src
	mmToServiceUserDataPrivate.defaultExpectation.expectationOrigins.originSrc = minimock.CallerInfo(1)

	return mmToServiceUserDataPrivate
}

// Inspect accepts an inspector function that has same arguments as the ServiceConverter.ToServiceUserDataPrivate
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Inspect(f func(src *generated.PrivateUser)) *mServiceConverterMockToServiceUserDataPrivate {
	if mmToServiceUserDataPrivate.mock.inspectFuncToServiceUserDataPrivate != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("Inspect function is already set for ServiceConverterMock.ToServiceUserDataPrivate")
	}

	mmToServiceUserDataPrivate.mock.inspectFuncToServiceUserDataPrivate = f

	return mmToServiceUserDataPrivate
}

// Return sets up results that will be returned by ServiceConverter.ToServiceUserDataPrivate
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Return(up1 *model.UserDataPrivate) *ServiceConverterMock {
	if mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivate != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPrivate mock is already set by Set")
	}

	if mmToServiceUserDataPrivate.defaultExpectation == nil {
		mmToServiceUserDataPrivate.defaultExpectation = &ServiceConverterMockToServiceUserDataPrivateExpectation{mock: mmToServiceUserDataPrivate.mock}
	}
	mmToServiceUserDataPrivate.defaultExpectation.results = &ServiceConverterMockToServiceUserDataPrivateResults{up1}
	mmToServiceUserDataPrivate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPrivate.mock
}

// Set uses given function f to mock the ServiceConverter.ToServiceUserDataPrivate method
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Set(f func(src *generated.PrivateUser) (up1 *model.UserDataPrivate)) *ServiceConverterMock {
	if mmToServiceUserDataPrivate.defaultExpectation != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("Default expectation is already set for the ServiceConverter.ToServiceUserDataPrivate method")
	}

	if len(mmToServiceUserDataPrivate.expectations) > 0 {
		mmToServiceUserDataPrivate.mock.t.Fatalf("Some expectations are already set for the ServiceConverter.ToServiceUserDataPrivate method")
	}

	mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivate = f
	mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivateOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPrivate.mock
}

// When sets expectation for the ServiceConverter.ToServiceUserDataPrivate which will trigger the result defined by the following
// Then helper
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) When(src *generated.PrivateUser) *ServiceConverterMockToServiceUserDataPrivateExpectation {
	if mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivate != nil {
		mmToServiceUserDataPrivate.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPrivate mock is already set by Set")
	}

	expectation := &ServiceConverterMockToServiceUserDataPrivateExpectation{
		mock:               mmToServiceUserDataPrivate.mock,
		params:             &ServiceConverterMockToServiceUserDataPrivateParams{src},
		expectationOrigins: ServiceConverterMockToServiceUserDataPrivateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToServiceUserDataPrivate.expectations = append(mmToServiceUserDataPrivate.expectations, expectation)
	return expectation
}

// Then sets up ServiceConverter.ToServiceUserDataPrivate return parameters for the expectation previously defined by the When method
func (e *ServiceConverterMockToServiceUserDataPrivateExpectation) Then(up1 *model.UserDataPrivate) *ServiceConverterMock {
	e.results = &ServiceConverterMockToServiceUserDataPrivateResults{up1}
	return e.mock
}

// Times sets number of times ServiceConverter.ToServiceUserDataPrivate should be invoked
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Times(n uint64) *mServiceConverterMockToServiceUserDataPrivate {
	if n == 0 {
		mmToServiceUserDataPrivate.mock.t.Fatalf("Times of ServiceConverterMock.ToServiceUserDataPrivate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToServiceUserDataPrivate.expectedInvocations, n)
	mmToServiceUserDataPrivate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPrivate
}

func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) invocationsDone() bool {
	if len(mmToServiceUserDataPrivate.expectations) == 0 && mmToServiceUserDataPrivate.defaultExpectation == nil && mmToServiceUserDataPrivate.mock.funcToServiceUserDataPrivate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToServiceUserDataPrivate.mock.afterToServiceUserDataPrivateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToServiceUserDataPrivate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToServiceUserDataPrivate implements mm_service.ServiceConverter
func (mmToServiceUserDataPrivate *ServiceConverterMock) ToServiceUserDataPrivate(src *generated.PrivateUser) (up1 *model.UserDataPrivate) {
	mm_atomic.AddUint64(&mmToServiceUserDataPrivate.beforeToServiceUserDataPrivateCounter, 1)
	defer mm_atomic.AddUint64(&mmToServiceUserDataPrivate.afterToServiceUserDataPrivateCounter, 1)

	mmToServiceUserDataPrivate.t.Helper()

	if mmToServiceUserDataPrivate.inspectFuncToServiceUserDataPrivate != nil {
		mmToServiceUserDataPrivate.inspectFuncToServiceUserDataPrivate(src)
	}

	mm_params := ServiceConverterMockToServiceUserDataPrivateParams{src}

	// Record call args
	mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.mutex.Lock()
	mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.callArgs = append(mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.callArgs, &mm_params)
	mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.mutex.Unlock()

	for _, e := range mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1
		}
	}

	if mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation.Counter, 1)
		mm_want := mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation.params
		mm_want_ptrs := mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation.paramPtrs

		mm_got := ServiceConverterMockToServiceUserDataPrivateParams{src}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.src != nil && !minimock.Equal(*mm_want_ptrs.src, mm_got.src) {
				mmToServiceUserDataPrivate.t.Errorf("ServiceConverterMock.ToServiceUserDataPrivate got unexpected parameter src, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation.expectationOrigins.originSrc, *mm_want_ptrs.src, mm_got.src, minimock.Diff(*mm_want_ptrs.src, mm_got.src))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToServiceUserDataPrivate.t.Errorf("ServiceConverterMock.ToServiceUserDataPrivate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToServiceUserDataPrivate.ToServiceUserDataPrivateMock.defaultExpectation.results
		if mm_results == nil {
			mmToServiceUserDataPrivate.t.Fatal("No results are set for the ServiceConverterMock.ToServiceUserDataPrivate")
		}
		return (*mm_results).up1
	}
	if mmToServiceUserDataPrivate.funcToServiceUserDataPrivate != nil {
		return mmToServiceUserDataPrivate.funcToServiceUserDataPrivate(src)
	}
	mmToServiceUserDataPrivate.t.Fatalf("Unexpected call to ServiceConverterMock.ToServiceUserDataPrivate. %v", src)
	return
}

// ToServiceUserDataPrivateAfterCounter returns a count of finished ServiceConverterMock.ToServiceUserDataPrivate invocations
func (mmToServiceUserDataPrivate *ServiceConverterMock) ToServiceUserDataPrivateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToServiceUserDataPrivate.afterToServiceUserDataPrivateCounter)
}

// ToServiceUserDataPrivateBeforeCounter returns a count of ServiceConverterMock.ToServiceUserDataPrivate invocations
func (mmToServiceUserDataPrivate *ServiceConverterMock) ToServiceUserDataPrivateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToServiceUserDataPrivate.beforeToServiceUserDataPrivateCounter)
}

// Calls returns a list of arguments used in each call to ServiceConverterMock.ToServiceUserDataPrivate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToServiceUserDataPrivate *mServiceConverterMockToServiceUserDataPrivate) Calls() []*ServiceConverterMockToServiceUserDataPrivateParams {
	mmToServiceUserDataPrivate.mutex.RLock()

	argCopy := make([]*ServiceConverterMockToServiceUserDataPrivateParams, len(mmToServiceUserDataPrivate.callArgs))
	copy(argCopy, mmToServiceUserDataPrivate.callArgs)

	mmToServiceUserDataPrivate.mutex.RUnlock()

	return argCopy
}

// MinimockToServiceUserDataPrivateDone returns true if the count of the ToServiceUserDataPrivate invocations corresponds
// the number of defined expectations
func (m *ServiceConverterMock) MinimockToServiceUserDataPrivateDone() bool {
	if m.ToServiceUserDataPrivateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToServiceUserDataPrivateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToServiceUserDataPrivateMock.invocationsDone()
}

// MinimockToServiceUserDataPrivateInspect logs each unmet expectation
func (m *ServiceConverterMock) MinimockToServiceUserDataPrivateInspect() {
	for _, e := range m.ToServiceUserDataPrivateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPrivate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToServiceUserDataPrivateCounter := mm_atomic.LoadUint64(&m.afterToServiceUserDataPrivateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToServiceUserDataPrivateMock.defaultExpectation != nil && afterToServiceUserDataPrivateCounter < 1 {
		if m.ToServiceUserDataPrivateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPrivate at\n%s", m.ToServiceUserDataPrivateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPrivate at\n%s with params: %#v", m.ToServiceUserDataPrivateMock.defaultExpectation.expectationOrigins.origin, *m.ToServiceUserDataPrivateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToServiceUserDataPrivate != nil && afterToServiceUserDataPrivateCounter < 1 {
		m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPrivate at\n%s", m.funcToServiceUserDataPrivateOrigin)
	}

	if !m.ToServiceUserDataPrivateMock.invocationsDone() && afterToServiceUserDataPrivateCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceConverterMock.ToServiceUserDataPrivate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToServiceUserDataPrivateMock.expectedInvocations), m.ToServiceUserDataPrivateMock.expectedInvocationsOrigin, afterToServiceUserDataPrivateCounter)
	}
}

type mServiceConverterMockToServiceUserDataPublic struct {
	optional           bool
	mock               *ServiceConverterMock
	defaultExpectation *ServiceConverterMockToServiceUserDataPublicExpectation
	expectations       []*ServiceConverterMockToServiceUserDataPublicExpectation

	callArgs []*ServiceConverterMockToServiceUserDataPublicParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ServiceConverterMockToServiceUserDataPublicExpectation specifies expectation struct of the ServiceConverter.ToServiceUserDataPublic
type ServiceConverterMockToServiceUserDataPublicExpectation struct {
	mock               *ServiceConverterMock
	params             *ServiceConverterMockToServiceUserDataPublicParams
	paramPtrs          *ServiceConverterMockToServiceUserDataPublicParamPtrs
	expectationOrigins ServiceConverterMockToServiceUserDataPublicExpectationOrigins
	results            *ServiceConverterMockToServiceUserDataPublicResults
	returnOrigin       string
	Counter            uint64
}

// ServiceConverterMockToServiceUserDataPublicParams contains parameters of the ServiceConverter.ToServiceUserDataPublic
type ServiceConverterMockToServiceUserDataPublicParams struct {
	src *generated.PublicUser
}

// ServiceConverterMockToServiceUserDataPublicParamPtrs contains pointers to parameters of the ServiceConverter.ToServiceUserDataPublic
type ServiceConverterMockToServiceUserDataPublicParamPtrs struct {
	src **generated.PublicUser
}

// ServiceConverterMockToServiceUserDataPublicResults contains results of the ServiceConverter.ToServiceUserDataPublic
type ServiceConverterMockToServiceUserDataPublicResults struct {
	up1 *model.UserDataPublic
}

// ServiceConverterMockToServiceUserDataPublicOrigins contains origins of expectations of the ServiceConverter.ToServiceUserDataPublic
type ServiceConverterMockToServiceUserDataPublicExpectationOrigins struct {
	origin    string
	originSrc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Optional() *mServiceConverterMockToServiceUserDataPublic {
	mmToServiceUserDataPublic.optional = true
	return mmToServiceUserDataPublic
}

// Expect sets up expected params for ServiceConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Expect(src *generated.PublicUser) *mServiceConverterMockToServiceUserDataPublic {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	if mmToServiceUserDataPublic.defaultExpectation == nil {
		mmToServiceUserDataPublic.defaultExpectation = &ServiceConverterMockToServiceUserDataPublicExpectation{}
	}

	if mmToServiceUserDataPublic.defaultExpectation.paramPtrs != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPublic mock is already set by ExpectParams functions")
	}

	mmToServiceUserDataPublic.defaultExpectation.params = &ServiceConverterMockToServiceUserDataPublicParams{src}
	mmToServiceUserDataPublic.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToServiceUserDataPublic.expectations {
		if minimock.Equal(e.params, mmToServiceUserDataPublic.defaultExpectation.params) {
			mmToServiceUserDataPublic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToServiceUserDataPublic.defaultExpectation.params)
		}
	}

	return mmToServiceUserDataPublic
}

// ExpectSrcParam1 sets up expected param src for ServiceConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) ExpectSrcParam1(src *generated.PublicUser) *mServiceConverterMockToServiceUserDataPublic {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	if mmToServiceUserDataPublic.defaultExpectation == nil {
		mmToServiceUserDataPublic.defaultExpectation = &ServiceConverterMockToServiceUserDataPublicExpectation{}
	}

	if mmToServiceUserDataPublic.defaultExpectation.params != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPublic mock is already set by Expect")
	}

	if mmToServiceUserDataPublic.defaultExpectation.paramPtrs == nil {
		mmToServiceUserDataPublic.defaultExpectation.paramPtrs = &ServiceConverterMockToServiceUserDataPublicParamPtrs{}
	}
	mmToServiceUserDataPublic.defaultExpectation.paramPtrs.src = &src
	mmToServiceUserDataPublic.defaultExpectation.expectationOrigins.originSrc = minimock.CallerInfo(1)

	return mmToServiceUserDataPublic
}

// Inspect accepts an inspector function that has same arguments as the ServiceConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Inspect(f func(src *generated.PublicUser)) *mServiceConverterMockToServiceUserDataPublic {
	if mmToServiceUserDataPublic.mock.inspectFuncToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("Inspect function is already set for ServiceConverterMock.ToServiceUserDataPublic")
	}

	mmToServiceUserDataPublic.mock.inspectFuncToServiceUserDataPublic = f

	return mmToServiceUserDataPublic
}

// Return sets up results that will be returned by ServiceConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Return(up1 *model.UserDataPublic) *ServiceConverterMock {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	if mmToServiceUserDataPublic.defaultExpectation == nil {
		mmToServiceUserDataPublic.defaultExpectation = &ServiceConverterMockToServiceUserDataPublicExpectation{mock: mmToServiceUserDataPublic.mock}
	}
	mmToServiceUserDataPublic.defaultExpectation.results = &ServiceConverterMockToServiceUserDataPublicResults{up1}
	mmToServiceUserDataPublic.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPublic.mock
}

// Set uses given function f to mock the ServiceConverter.ToServiceUserDataPublic method
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Set(f func(src *generated.PublicUser) (up1 *model.UserDataPublic)) *ServiceConverterMock {
	if mmToServiceUserDataPublic.defaultExpectation != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("Default expectation is already set for the ServiceConverter.ToServiceUserDataPublic method")
	}

	if len(mmToServiceUserDataPublic.expectations) > 0 {
		mmToServiceUserDataPublic.mock.t.Fatalf("Some expectations are already set for the ServiceConverter.ToServiceUserDataPublic method")
	}

	mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic = f
	mmToServiceUserDataPublic.mock.funcToServiceUserDataPublicOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPublic.mock
}

// When sets expectation for the ServiceConverter.ToServiceUserDataPublic which will trigger the result defined by the following
// Then helper
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) When(src *generated.PublicUser) *ServiceConverterMockToServiceUserDataPublicExpectation {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("ServiceConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	expectation := &ServiceConverterMockToServiceUserDataPublicExpectation{
		mock:               mmToServiceUserDataPublic.mock,
		params:             &ServiceConverterMockToServiceUserDataPublicParams{src},
		expectationOrigins: ServiceConverterMockToServiceUserDataPublicExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToServiceUserDataPublic.expectations = append(mmToServiceUserDataPublic.expectations, expectation)
	return expectation
}

// Then sets up ServiceConverter.ToServiceUserDataPublic return parameters for the expectation previously defined by the When method
func (e *ServiceConverterMockToServiceUserDataPublicExpectation) Then(up1 *model.UserDataPublic) *ServiceConverterMock {
	e.results = &ServiceConverterMockToServiceUserDataPublicResults{up1}
	return e.mock
}

// Times sets number of times ServiceConverter.ToServiceUserDataPublic should be invoked
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Times(n uint64) *mServiceConverterMockToServiceUserDataPublic {
	if n == 0 {
		mmToServiceUserDataPublic.mock.t.Fatalf("Times of ServiceConverterMock.ToServiceUserDataPublic mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToServiceUserDataPublic.expectedInvocations, n)
	mmToServiceUserDataPublic.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPublic
}

func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) invocationsDone() bool {
	if len(mmToServiceUserDataPublic.expectations) == 0 && mmToServiceUserDataPublic.defaultExpectation == nil && mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToServiceUserDataPublic.mock.afterToServiceUserDataPublicCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToServiceUserDataPublic.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToServiceUserDataPublic implements mm_service.ServiceConverter
func (mmToServiceUserDataPublic *ServiceConverterMock) ToServiceUserDataPublic(src *generated.PublicUser) (up1 *model.UserDataPublic) {
	mm_atomic.AddUint64(&mmToServiceUserDataPublic.beforeToServiceUserDataPublicCounter, 1)
	defer mm_atomic.AddUint64(&mmToServiceUserDataPublic.afterToServiceUserDataPublicCounter, 1)

	mmToServiceUserDataPublic.t.Helper()

	if mmToServiceUserDataPublic.inspectFuncToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.inspectFuncToServiceUserDataPublic(src)
	}

	mm_params := ServiceConverterMockToServiceUserDataPublicParams{src}

	// Record call args
	mmToServiceUserDataPublic.ToServiceUserDataPublicMock.mutex.Lock()
	mmToServiceUserDataPublic.ToServiceUserDataPublicMock.callArgs = append(mmToServiceUserDataPublic.ToServiceUserDataPublicMock.callArgs, &mm_params)
	mmToServiceUserDataPublic.ToServiceUserDataPublicMock.mutex.Unlock()

	for _, e := range mmToServiceUserDataPublic.ToServiceUserDataPublicMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1
		}
	}

	if mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.Counter, 1)
		mm_want := mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.params
		mm_want_ptrs := mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.paramPtrs

		mm_got := ServiceConverterMockToServiceUserDataPublicParams{src}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.src != nil && !minimock.Equal(*mm_want_ptrs.src, mm_got.src) {
				mmToServiceUserDataPublic.t.Errorf("ServiceConverterMock.ToServiceUserDataPublic got unexpected parameter src, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.expectationOrigins.originSrc, *mm_want_ptrs.src, mm_got.src, minimock.Diff(*mm_want_ptrs.src, mm_got.src))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToServiceUserDataPublic.t.Errorf("ServiceConverterMock.ToServiceUserDataPublic got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.results
		if mm_results == nil {
			mmToServiceUserDataPublic.t.Fatal("No results are set for the ServiceConverterMock.ToServiceUserDataPublic")
		}
		return (*mm_results).up1
	}
	if mmToServiceUserDataPublic.funcToServiceUserDataPublic != nil {
		return mmToServiceUserDataPublic.funcToServiceUserDataPublic(src)
	}
	mmToServiceUserDataPublic.t.Fatalf("Unexpected call to ServiceConverterMock.ToServiceUserDataPublic. %v", src)
	return
}

// ToServiceUserDataPublicAfterCounter returns a count of finished ServiceConverterMock.ToServiceUserDataPublic invocations
func (mmToServiceUserDataPublic *ServiceConverterMock) ToServiceUserDataPublicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToServiceUserDataPublic.afterToServiceUserDataPublicCounter)
}

// ToServiceUserDataPublicBeforeCounter returns a count of ServiceConverterMock.ToServiceUserDataPublic invocations
func (mmToServiceUserDataPublic *ServiceConverterMock) ToServiceUserDataPublicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToServiceUserDataPublic.beforeToServiceUserDataPublicCounter)
}

// Calls returns a list of arguments used in each call to ServiceConverterMock.ToServiceUserDataPublic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToServiceUserDataPublic *mServiceConverterMockToServiceUserDataPublic) Calls() []*ServiceConverterMockToServiceUserDataPublicParams {
	mmToServiceUserDataPublic.mutex.RLock()

	argCopy := make([]*ServiceConverterMockToServiceUserDataPublicParams, len(mmToServiceUserDataPublic.callArgs))
	copy(argCopy, mmToServiceUserDataPublic.callArgs)

	mmToServiceUserDataPublic.mutex.RUnlock()

	return argCopy
}

// MinimockToServiceUserDataPublicDone returns true if the count of the ToServiceUserDataPublic invocations corresponds
// the number of defined expectations
func (m *ServiceConverterMock) MinimockToServiceUserDataPublicDone() bool {
	if m.ToServiceUserDataPublicMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToServiceUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToServiceUserDataPublicMock.invocationsDone()
}

// MinimockToServiceUserDataPublicInspect logs each unmet expectation
func (m *ServiceConverterMock) MinimockToServiceUserDataPublicInspect() {
	for _, e := range m.ToServiceUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPublic at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToServiceUserDataPublicCounter := mm_atomic.LoadUint64(&m.afterToServiceUserDataPublicCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToServiceUserDataPublicMock.defaultExpectation != nil && afterToServiceUserDataPublicCounter < 1 {
		if m.ToServiceUserDataPublicMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPublic at\n%s", m.ToServiceUserDataPublicMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPublic at\n%s with params: %#v", m.ToServiceUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *m.ToServiceUserDataPublicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToServiceUserDataPublic != nil && afterToServiceUserDataPublicCounter < 1 {
		m.t.Errorf("Expected call to ServiceConverterMock.ToServiceUserDataPublic at\n%s", m.funcToServiceUserDataPublicOrigin)
	}

	if !m.ToServiceUserDataPublicMock.invocationsDone() && afterToServiceUserDataPublicCounter > 0 {
		m.t.Errorf("Expected %d calls to ServiceConverterMock.ToServiceUserDataPublic at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToServiceUserDataPublicMock.expectedInvocations), m.ToServiceUserDataPublicMock.expectedInvocationsOrigin, afterToServiceUserDataPublicCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceConverterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockToProtoGetResponseInspect()

			m.MinimockToProtoPublicUserInspect()

			m.MinimockToProtoUserDataPrivateInspect()

			m.MinimockToProtoUserDataPublicInspect()

			m.MinimockToServiceUserDataPrivateInspect()

			m.MinimockToServiceUserDataPublicInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceConverterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceConverterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockToProtoGetResponseDone() &&
		m.MinimockToProtoPublicUserDone() &&
		m.MinimockToProtoUserDataPrivateDone() &&
		m.MinimockToProtoUserDataPublicDone() &&
		m.MinimockToServiceUserDataPrivateDone() &&
		m.MinimockToServiceUserDataPublicDone()
}
