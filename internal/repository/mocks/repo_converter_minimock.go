// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Ghaarp/auth/internal/repository.RepoConverter -o repo_converter_minimock.go -n RepoConverterMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	repoModel "github.com/Ghaarp/auth/internal/repository/auth/model"
	serviceModel "github.com/Ghaarp/auth/internal/service/auth/model"
	"github.com/gojuno/minimock/v3"
)

// RepoConverterMock implements mm_repository.RepoConverter
type RepoConverterMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcToRepoUserDataPrivate          func(src *serviceModel.UserDataPrivate) (up1 *repoModel.UserDataPrivate)
	funcToRepoUserDataPrivateOrigin    string
	inspectFuncToRepoUserDataPrivate   func(src *serviceModel.UserDataPrivate)
	afterToRepoUserDataPrivateCounter  uint64
	beforeToRepoUserDataPrivateCounter uint64
	ToRepoUserDataPrivateMock          mRepoConverterMockToRepoUserDataPrivate

	funcToRepoUserDataPublic          func(src *serviceModel.UserDataPublic) (up1 *repoModel.UserDataPublic)
	funcToRepoUserDataPublicOrigin    string
	inspectFuncToRepoUserDataPublic   func(src *serviceModel.UserDataPublic)
	afterToRepoUserDataPublicCounter  uint64
	beforeToRepoUserDataPublicCounter uint64
	ToRepoUserDataPublicMock          mRepoConverterMockToRepoUserDataPublic

	funcToServiceUserDataPublic          func(src *repoModel.UserDataPublic) (up1 *serviceModel.UserDataPublic)
	funcToServiceUserDataPublicOrigin    string
	inspectFuncToServiceUserDataPublic   func(src *repoModel.UserDataPublic)
	afterToServiceUserDataPublicCounter  uint64
	beforeToServiceUserDataPublicCounter uint64
	ToServiceUserDataPublicMock          mRepoConverterMockToServiceUserDataPublic
}

// NewRepoConverterMock returns a mock for mm_repository.RepoConverter
func NewRepoConverterMock(t minimock.Tester) *RepoConverterMock {
	m := &RepoConverterMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ToRepoUserDataPrivateMock = mRepoConverterMockToRepoUserDataPrivate{mock: m}
	m.ToRepoUserDataPrivateMock.callArgs = []*RepoConverterMockToRepoUserDataPrivateParams{}

	m.ToRepoUserDataPublicMock = mRepoConverterMockToRepoUserDataPublic{mock: m}
	m.ToRepoUserDataPublicMock.callArgs = []*RepoConverterMockToRepoUserDataPublicParams{}

	m.ToServiceUserDataPublicMock = mRepoConverterMockToServiceUserDataPublic{mock: m}
	m.ToServiceUserDataPublicMock.callArgs = []*RepoConverterMockToServiceUserDataPublicParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepoConverterMockToRepoUserDataPrivate struct {
	optional           bool
	mock               *RepoConverterMock
	defaultExpectation *RepoConverterMockToRepoUserDataPrivateExpectation
	expectations       []*RepoConverterMockToRepoUserDataPrivateExpectation

	callArgs []*RepoConverterMockToRepoUserDataPrivateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepoConverterMockToRepoUserDataPrivateExpectation specifies expectation struct of the RepoConverter.ToRepoUserDataPrivate
type RepoConverterMockToRepoUserDataPrivateExpectation struct {
	mock               *RepoConverterMock
	params             *RepoConverterMockToRepoUserDataPrivateParams
	paramPtrs          *RepoConverterMockToRepoUserDataPrivateParamPtrs
	expectationOrigins RepoConverterMockToRepoUserDataPrivateExpectationOrigins
	results            *RepoConverterMockToRepoUserDataPrivateResults
	returnOrigin       string
	Counter            uint64
}

// RepoConverterMockToRepoUserDataPrivateParams contains parameters of the RepoConverter.ToRepoUserDataPrivate
type RepoConverterMockToRepoUserDataPrivateParams struct {
	src *serviceModel.UserDataPrivate
}

// RepoConverterMockToRepoUserDataPrivateParamPtrs contains pointers to parameters of the RepoConverter.ToRepoUserDataPrivate
type RepoConverterMockToRepoUserDataPrivateParamPtrs struct {
	src **serviceModel.UserDataPrivate
}

// RepoConverterMockToRepoUserDataPrivateResults contains results of the RepoConverter.ToRepoUserDataPrivate
type RepoConverterMockToRepoUserDataPrivateResults struct {
	up1 *repoModel.UserDataPrivate
}

// RepoConverterMockToRepoUserDataPrivateOrigins contains origins of expectations of the RepoConverter.ToRepoUserDataPrivate
type RepoConverterMockToRepoUserDataPrivateExpectationOrigins struct {
	origin    string
	originSrc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Optional() *mRepoConverterMockToRepoUserDataPrivate {
	mmToRepoUserDataPrivate.optional = true
	return mmToRepoUserDataPrivate
}

// Expect sets up expected params for RepoConverter.ToRepoUserDataPrivate
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Expect(src *serviceModel.UserDataPrivate) *mRepoConverterMockToRepoUserDataPrivate {
	if mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivate != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPrivate mock is already set by Set")
	}

	if mmToRepoUserDataPrivate.defaultExpectation == nil {
		mmToRepoUserDataPrivate.defaultExpectation = &RepoConverterMockToRepoUserDataPrivateExpectation{}
	}

	if mmToRepoUserDataPrivate.defaultExpectation.paramPtrs != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPrivate mock is already set by ExpectParams functions")
	}

	mmToRepoUserDataPrivate.defaultExpectation.params = &RepoConverterMockToRepoUserDataPrivateParams{src}
	mmToRepoUserDataPrivate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToRepoUserDataPrivate.expectations {
		if minimock.Equal(e.params, mmToRepoUserDataPrivate.defaultExpectation.params) {
			mmToRepoUserDataPrivate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToRepoUserDataPrivate.defaultExpectation.params)
		}
	}

	return mmToRepoUserDataPrivate
}

// ExpectSrcParam1 sets up expected param src for RepoConverter.ToRepoUserDataPrivate
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) ExpectSrcParam1(src *serviceModel.UserDataPrivate) *mRepoConverterMockToRepoUserDataPrivate {
	if mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivate != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPrivate mock is already set by Set")
	}

	if mmToRepoUserDataPrivate.defaultExpectation == nil {
		mmToRepoUserDataPrivate.defaultExpectation = &RepoConverterMockToRepoUserDataPrivateExpectation{}
	}

	if mmToRepoUserDataPrivate.defaultExpectation.params != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPrivate mock is already set by Expect")
	}

	if mmToRepoUserDataPrivate.defaultExpectation.paramPtrs == nil {
		mmToRepoUserDataPrivate.defaultExpectation.paramPtrs = &RepoConverterMockToRepoUserDataPrivateParamPtrs{}
	}
	mmToRepoUserDataPrivate.defaultExpectation.paramPtrs.src = &src
	mmToRepoUserDataPrivate.defaultExpectation.expectationOrigins.originSrc = minimock.CallerInfo(1)

	return mmToRepoUserDataPrivate
}

// Inspect accepts an inspector function that has same arguments as the RepoConverter.ToRepoUserDataPrivate
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Inspect(f func(src *serviceModel.UserDataPrivate)) *mRepoConverterMockToRepoUserDataPrivate {
	if mmToRepoUserDataPrivate.mock.inspectFuncToRepoUserDataPrivate != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("Inspect function is already set for RepoConverterMock.ToRepoUserDataPrivate")
	}

	mmToRepoUserDataPrivate.mock.inspectFuncToRepoUserDataPrivate = f

	return mmToRepoUserDataPrivate
}

// Return sets up results that will be returned by RepoConverter.ToRepoUserDataPrivate
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Return(up1 *repoModel.UserDataPrivate) *RepoConverterMock {
	if mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivate != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPrivate mock is already set by Set")
	}

	if mmToRepoUserDataPrivate.defaultExpectation == nil {
		mmToRepoUserDataPrivate.defaultExpectation = &RepoConverterMockToRepoUserDataPrivateExpectation{mock: mmToRepoUserDataPrivate.mock}
	}
	mmToRepoUserDataPrivate.defaultExpectation.results = &RepoConverterMockToRepoUserDataPrivateResults{up1}
	mmToRepoUserDataPrivate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToRepoUserDataPrivate.mock
}

// Set uses given function f to mock the RepoConverter.ToRepoUserDataPrivate method
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Set(f func(src *serviceModel.UserDataPrivate) (up1 *repoModel.UserDataPrivate)) *RepoConverterMock {
	if mmToRepoUserDataPrivate.defaultExpectation != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("Default expectation is already set for the RepoConverter.ToRepoUserDataPrivate method")
	}

	if len(mmToRepoUserDataPrivate.expectations) > 0 {
		mmToRepoUserDataPrivate.mock.t.Fatalf("Some expectations are already set for the RepoConverter.ToRepoUserDataPrivate method")
	}

	mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivate = f
	mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivateOrigin = minimock.CallerInfo(1)
	return mmToRepoUserDataPrivate.mock
}

// When sets expectation for the RepoConverter.ToRepoUserDataPrivate which will trigger the result defined by the following
// Then helper
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) When(src *serviceModel.UserDataPrivate) *RepoConverterMockToRepoUserDataPrivateExpectation {
	if mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivate != nil {
		mmToRepoUserDataPrivate.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPrivate mock is already set by Set")
	}

	expectation := &RepoConverterMockToRepoUserDataPrivateExpectation{
		mock:               mmToRepoUserDataPrivate.mock,
		params:             &RepoConverterMockToRepoUserDataPrivateParams{src},
		expectationOrigins: RepoConverterMockToRepoUserDataPrivateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToRepoUserDataPrivate.expectations = append(mmToRepoUserDataPrivate.expectations, expectation)
	return expectation
}

// Then sets up RepoConverter.ToRepoUserDataPrivate return parameters for the expectation previously defined by the When method
func (e *RepoConverterMockToRepoUserDataPrivateExpectation) Then(up1 *repoModel.UserDataPrivate) *RepoConverterMock {
	e.results = &RepoConverterMockToRepoUserDataPrivateResults{up1}
	return e.mock
}

// Times sets number of times RepoConverter.ToRepoUserDataPrivate should be invoked
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Times(n uint64) *mRepoConverterMockToRepoUserDataPrivate {
	if n == 0 {
		mmToRepoUserDataPrivate.mock.t.Fatalf("Times of RepoConverterMock.ToRepoUserDataPrivate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToRepoUserDataPrivate.expectedInvocations, n)
	mmToRepoUserDataPrivate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToRepoUserDataPrivate
}

func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) invocationsDone() bool {
	if len(mmToRepoUserDataPrivate.expectations) == 0 && mmToRepoUserDataPrivate.defaultExpectation == nil && mmToRepoUserDataPrivate.mock.funcToRepoUserDataPrivate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToRepoUserDataPrivate.mock.afterToRepoUserDataPrivateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToRepoUserDataPrivate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToRepoUserDataPrivate implements mm_repository.RepoConverter
func (mmToRepoUserDataPrivate *RepoConverterMock) ToRepoUserDataPrivate(src *serviceModel.UserDataPrivate) (up1 *repoModel.UserDataPrivate) {
	mm_atomic.AddUint64(&mmToRepoUserDataPrivate.beforeToRepoUserDataPrivateCounter, 1)
	defer mm_atomic.AddUint64(&mmToRepoUserDataPrivate.afterToRepoUserDataPrivateCounter, 1)

	mmToRepoUserDataPrivate.t.Helper()

	if mmToRepoUserDataPrivate.inspectFuncToRepoUserDataPrivate != nil {
		mmToRepoUserDataPrivate.inspectFuncToRepoUserDataPrivate(src)
	}

	mm_params := RepoConverterMockToRepoUserDataPrivateParams{src}

	// Record call args
	mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.mutex.Lock()
	mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.callArgs = append(mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.callArgs, &mm_params)
	mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.mutex.Unlock()

	for _, e := range mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1
		}
	}

	if mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation.Counter, 1)
		mm_want := mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation.params
		mm_want_ptrs := mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation.paramPtrs

		mm_got := RepoConverterMockToRepoUserDataPrivateParams{src}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.src != nil && !minimock.Equal(*mm_want_ptrs.src, mm_got.src) {
				mmToRepoUserDataPrivate.t.Errorf("RepoConverterMock.ToRepoUserDataPrivate got unexpected parameter src, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation.expectationOrigins.originSrc, *mm_want_ptrs.src, mm_got.src, minimock.Diff(*mm_want_ptrs.src, mm_got.src))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToRepoUserDataPrivate.t.Errorf("RepoConverterMock.ToRepoUserDataPrivate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToRepoUserDataPrivate.ToRepoUserDataPrivateMock.defaultExpectation.results
		if mm_results == nil {
			mmToRepoUserDataPrivate.t.Fatal("No results are set for the RepoConverterMock.ToRepoUserDataPrivate")
		}
		return (*mm_results).up1
	}
	if mmToRepoUserDataPrivate.funcToRepoUserDataPrivate != nil {
		return mmToRepoUserDataPrivate.funcToRepoUserDataPrivate(src)
	}
	mmToRepoUserDataPrivate.t.Fatalf("Unexpected call to RepoConverterMock.ToRepoUserDataPrivate. %v", src)
	return
}

// ToRepoUserDataPrivateAfterCounter returns a count of finished RepoConverterMock.ToRepoUserDataPrivate invocations
func (mmToRepoUserDataPrivate *RepoConverterMock) ToRepoUserDataPrivateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToRepoUserDataPrivate.afterToRepoUserDataPrivateCounter)
}

// ToRepoUserDataPrivateBeforeCounter returns a count of RepoConverterMock.ToRepoUserDataPrivate invocations
func (mmToRepoUserDataPrivate *RepoConverterMock) ToRepoUserDataPrivateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToRepoUserDataPrivate.beforeToRepoUserDataPrivateCounter)
}

// Calls returns a list of arguments used in each call to RepoConverterMock.ToRepoUserDataPrivate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToRepoUserDataPrivate *mRepoConverterMockToRepoUserDataPrivate) Calls() []*RepoConverterMockToRepoUserDataPrivateParams {
	mmToRepoUserDataPrivate.mutex.RLock()

	argCopy := make([]*RepoConverterMockToRepoUserDataPrivateParams, len(mmToRepoUserDataPrivate.callArgs))
	copy(argCopy, mmToRepoUserDataPrivate.callArgs)

	mmToRepoUserDataPrivate.mutex.RUnlock()

	return argCopy
}

// MinimockToRepoUserDataPrivateDone returns true if the count of the ToRepoUserDataPrivate invocations corresponds
// the number of defined expectations
func (m *RepoConverterMock) MinimockToRepoUserDataPrivateDone() bool {
	if m.ToRepoUserDataPrivateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToRepoUserDataPrivateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToRepoUserDataPrivateMock.invocationsDone()
}

// MinimockToRepoUserDataPrivateInspect logs each unmet expectation
func (m *RepoConverterMock) MinimockToRepoUserDataPrivateInspect() {
	for _, e := range m.ToRepoUserDataPrivateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPrivate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToRepoUserDataPrivateCounter := mm_atomic.LoadUint64(&m.afterToRepoUserDataPrivateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToRepoUserDataPrivateMock.defaultExpectation != nil && afterToRepoUserDataPrivateCounter < 1 {
		if m.ToRepoUserDataPrivateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPrivate at\n%s", m.ToRepoUserDataPrivateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPrivate at\n%s with params: %#v", m.ToRepoUserDataPrivateMock.defaultExpectation.expectationOrigins.origin, *m.ToRepoUserDataPrivateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToRepoUserDataPrivate != nil && afterToRepoUserDataPrivateCounter < 1 {
		m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPrivate at\n%s", m.funcToRepoUserDataPrivateOrigin)
	}

	if !m.ToRepoUserDataPrivateMock.invocationsDone() && afterToRepoUserDataPrivateCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoConverterMock.ToRepoUserDataPrivate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToRepoUserDataPrivateMock.expectedInvocations), m.ToRepoUserDataPrivateMock.expectedInvocationsOrigin, afterToRepoUserDataPrivateCounter)
	}
}

type mRepoConverterMockToRepoUserDataPublic struct {
	optional           bool
	mock               *RepoConverterMock
	defaultExpectation *RepoConverterMockToRepoUserDataPublicExpectation
	expectations       []*RepoConverterMockToRepoUserDataPublicExpectation

	callArgs []*RepoConverterMockToRepoUserDataPublicParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepoConverterMockToRepoUserDataPublicExpectation specifies expectation struct of the RepoConverter.ToRepoUserDataPublic
type RepoConverterMockToRepoUserDataPublicExpectation struct {
	mock               *RepoConverterMock
	params             *RepoConverterMockToRepoUserDataPublicParams
	paramPtrs          *RepoConverterMockToRepoUserDataPublicParamPtrs
	expectationOrigins RepoConverterMockToRepoUserDataPublicExpectationOrigins
	results            *RepoConverterMockToRepoUserDataPublicResults
	returnOrigin       string
	Counter            uint64
}

// RepoConverterMockToRepoUserDataPublicParams contains parameters of the RepoConverter.ToRepoUserDataPublic
type RepoConverterMockToRepoUserDataPublicParams struct {
	src *serviceModel.UserDataPublic
}

// RepoConverterMockToRepoUserDataPublicParamPtrs contains pointers to parameters of the RepoConverter.ToRepoUserDataPublic
type RepoConverterMockToRepoUserDataPublicParamPtrs struct {
	src **serviceModel.UserDataPublic
}

// RepoConverterMockToRepoUserDataPublicResults contains results of the RepoConverter.ToRepoUserDataPublic
type RepoConverterMockToRepoUserDataPublicResults struct {
	up1 *repoModel.UserDataPublic
}

// RepoConverterMockToRepoUserDataPublicOrigins contains origins of expectations of the RepoConverter.ToRepoUserDataPublic
type RepoConverterMockToRepoUserDataPublicExpectationOrigins struct {
	origin    string
	originSrc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Optional() *mRepoConverterMockToRepoUserDataPublic {
	mmToRepoUserDataPublic.optional = true
	return mmToRepoUserDataPublic
}

// Expect sets up expected params for RepoConverter.ToRepoUserDataPublic
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Expect(src *serviceModel.UserDataPublic) *mRepoConverterMockToRepoUserDataPublic {
	if mmToRepoUserDataPublic.mock.funcToRepoUserDataPublic != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPublic mock is already set by Set")
	}

	if mmToRepoUserDataPublic.defaultExpectation == nil {
		mmToRepoUserDataPublic.defaultExpectation = &RepoConverterMockToRepoUserDataPublicExpectation{}
	}

	if mmToRepoUserDataPublic.defaultExpectation.paramPtrs != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPublic mock is already set by ExpectParams functions")
	}

	mmToRepoUserDataPublic.defaultExpectation.params = &RepoConverterMockToRepoUserDataPublicParams{src}
	mmToRepoUserDataPublic.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToRepoUserDataPublic.expectations {
		if minimock.Equal(e.params, mmToRepoUserDataPublic.defaultExpectation.params) {
			mmToRepoUserDataPublic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToRepoUserDataPublic.defaultExpectation.params)
		}
	}

	return mmToRepoUserDataPublic
}

// ExpectSrcParam1 sets up expected param src for RepoConverter.ToRepoUserDataPublic
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) ExpectSrcParam1(src *serviceModel.UserDataPublic) *mRepoConverterMockToRepoUserDataPublic {
	if mmToRepoUserDataPublic.mock.funcToRepoUserDataPublic != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPublic mock is already set by Set")
	}

	if mmToRepoUserDataPublic.defaultExpectation == nil {
		mmToRepoUserDataPublic.defaultExpectation = &RepoConverterMockToRepoUserDataPublicExpectation{}
	}

	if mmToRepoUserDataPublic.defaultExpectation.params != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPublic mock is already set by Expect")
	}

	if mmToRepoUserDataPublic.defaultExpectation.paramPtrs == nil {
		mmToRepoUserDataPublic.defaultExpectation.paramPtrs = &RepoConverterMockToRepoUserDataPublicParamPtrs{}
	}
	mmToRepoUserDataPublic.defaultExpectation.paramPtrs.src = &src
	mmToRepoUserDataPublic.defaultExpectation.expectationOrigins.originSrc = minimock.CallerInfo(1)

	return mmToRepoUserDataPublic
}

// Inspect accepts an inspector function that has same arguments as the RepoConverter.ToRepoUserDataPublic
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Inspect(f func(src *serviceModel.UserDataPublic)) *mRepoConverterMockToRepoUserDataPublic {
	if mmToRepoUserDataPublic.mock.inspectFuncToRepoUserDataPublic != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("Inspect function is already set for RepoConverterMock.ToRepoUserDataPublic")
	}

	mmToRepoUserDataPublic.mock.inspectFuncToRepoUserDataPublic = f

	return mmToRepoUserDataPublic
}

// Return sets up results that will be returned by RepoConverter.ToRepoUserDataPublic
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Return(up1 *repoModel.UserDataPublic) *RepoConverterMock {
	if mmToRepoUserDataPublic.mock.funcToRepoUserDataPublic != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPublic mock is already set by Set")
	}

	if mmToRepoUserDataPublic.defaultExpectation == nil {
		mmToRepoUserDataPublic.defaultExpectation = &RepoConverterMockToRepoUserDataPublicExpectation{mock: mmToRepoUserDataPublic.mock}
	}
	mmToRepoUserDataPublic.defaultExpectation.results = &RepoConverterMockToRepoUserDataPublicResults{up1}
	mmToRepoUserDataPublic.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToRepoUserDataPublic.mock
}

// Set uses given function f to mock the RepoConverter.ToRepoUserDataPublic method
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Set(f func(src *serviceModel.UserDataPublic) (up1 *repoModel.UserDataPublic)) *RepoConverterMock {
	if mmToRepoUserDataPublic.defaultExpectation != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("Default expectation is already set for the RepoConverter.ToRepoUserDataPublic method")
	}

	if len(mmToRepoUserDataPublic.expectations) > 0 {
		mmToRepoUserDataPublic.mock.t.Fatalf("Some expectations are already set for the RepoConverter.ToRepoUserDataPublic method")
	}

	mmToRepoUserDataPublic.mock.funcToRepoUserDataPublic = f
	mmToRepoUserDataPublic.mock.funcToRepoUserDataPublicOrigin = minimock.CallerInfo(1)
	return mmToRepoUserDataPublic.mock
}

// When sets expectation for the RepoConverter.ToRepoUserDataPublic which will trigger the result defined by the following
// Then helper
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) When(src *serviceModel.UserDataPublic) *RepoConverterMockToRepoUserDataPublicExpectation {
	if mmToRepoUserDataPublic.mock.funcToRepoUserDataPublic != nil {
		mmToRepoUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToRepoUserDataPublic mock is already set by Set")
	}

	expectation := &RepoConverterMockToRepoUserDataPublicExpectation{
		mock:               mmToRepoUserDataPublic.mock,
		params:             &RepoConverterMockToRepoUserDataPublicParams{src},
		expectationOrigins: RepoConverterMockToRepoUserDataPublicExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToRepoUserDataPublic.expectations = append(mmToRepoUserDataPublic.expectations, expectation)
	return expectation
}

// Then sets up RepoConverter.ToRepoUserDataPublic return parameters for the expectation previously defined by the When method
func (e *RepoConverterMockToRepoUserDataPublicExpectation) Then(up1 *repoModel.UserDataPublic) *RepoConverterMock {
	e.results = &RepoConverterMockToRepoUserDataPublicResults{up1}
	return e.mock
}

// Times sets number of times RepoConverter.ToRepoUserDataPublic should be invoked
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Times(n uint64) *mRepoConverterMockToRepoUserDataPublic {
	if n == 0 {
		mmToRepoUserDataPublic.mock.t.Fatalf("Times of RepoConverterMock.ToRepoUserDataPublic mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToRepoUserDataPublic.expectedInvocations, n)
	mmToRepoUserDataPublic.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToRepoUserDataPublic
}

func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) invocationsDone() bool {
	if len(mmToRepoUserDataPublic.expectations) == 0 && mmToRepoUserDataPublic.defaultExpectation == nil && mmToRepoUserDataPublic.mock.funcToRepoUserDataPublic == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToRepoUserDataPublic.mock.afterToRepoUserDataPublicCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToRepoUserDataPublic.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToRepoUserDataPublic implements mm_repository.RepoConverter
func (mmToRepoUserDataPublic *RepoConverterMock) ToRepoUserDataPublic(src *serviceModel.UserDataPublic) (up1 *repoModel.UserDataPublic) {
	mm_atomic.AddUint64(&mmToRepoUserDataPublic.beforeToRepoUserDataPublicCounter, 1)
	defer mm_atomic.AddUint64(&mmToRepoUserDataPublic.afterToRepoUserDataPublicCounter, 1)

	mmToRepoUserDataPublic.t.Helper()

	if mmToRepoUserDataPublic.inspectFuncToRepoUserDataPublic != nil {
		mmToRepoUserDataPublic.inspectFuncToRepoUserDataPublic(src)
	}

	mm_params := RepoConverterMockToRepoUserDataPublicParams{src}

	// Record call args
	mmToRepoUserDataPublic.ToRepoUserDataPublicMock.mutex.Lock()
	mmToRepoUserDataPublic.ToRepoUserDataPublicMock.callArgs = append(mmToRepoUserDataPublic.ToRepoUserDataPublicMock.callArgs, &mm_params)
	mmToRepoUserDataPublic.ToRepoUserDataPublicMock.mutex.Unlock()

	for _, e := range mmToRepoUserDataPublic.ToRepoUserDataPublicMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1
		}
	}

	if mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation.Counter, 1)
		mm_want := mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation.params
		mm_want_ptrs := mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation.paramPtrs

		mm_got := RepoConverterMockToRepoUserDataPublicParams{src}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.src != nil && !minimock.Equal(*mm_want_ptrs.src, mm_got.src) {
				mmToRepoUserDataPublic.t.Errorf("RepoConverterMock.ToRepoUserDataPublic got unexpected parameter src, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation.expectationOrigins.originSrc, *mm_want_ptrs.src, mm_got.src, minimock.Diff(*mm_want_ptrs.src, mm_got.src))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToRepoUserDataPublic.t.Errorf("RepoConverterMock.ToRepoUserDataPublic got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToRepoUserDataPublic.ToRepoUserDataPublicMock.defaultExpectation.results
		if mm_results == nil {
			mmToRepoUserDataPublic.t.Fatal("No results are set for the RepoConverterMock.ToRepoUserDataPublic")
		}
		return (*mm_results).up1
	}
	if mmToRepoUserDataPublic.funcToRepoUserDataPublic != nil {
		return mmToRepoUserDataPublic.funcToRepoUserDataPublic(src)
	}
	mmToRepoUserDataPublic.t.Fatalf("Unexpected call to RepoConverterMock.ToRepoUserDataPublic. %v", src)
	return
}

// ToRepoUserDataPublicAfterCounter returns a count of finished RepoConverterMock.ToRepoUserDataPublic invocations
func (mmToRepoUserDataPublic *RepoConverterMock) ToRepoUserDataPublicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToRepoUserDataPublic.afterToRepoUserDataPublicCounter)
}

// ToRepoUserDataPublicBeforeCounter returns a count of RepoConverterMock.ToRepoUserDataPublic invocations
func (mmToRepoUserDataPublic *RepoConverterMock) ToRepoUserDataPublicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToRepoUserDataPublic.beforeToRepoUserDataPublicCounter)
}

// Calls returns a list of arguments used in each call to RepoConverterMock.ToRepoUserDataPublic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToRepoUserDataPublic *mRepoConverterMockToRepoUserDataPublic) Calls() []*RepoConverterMockToRepoUserDataPublicParams {
	mmToRepoUserDataPublic.mutex.RLock()

	argCopy := make([]*RepoConverterMockToRepoUserDataPublicParams, len(mmToRepoUserDataPublic.callArgs))
	copy(argCopy, mmToRepoUserDataPublic.callArgs)

	mmToRepoUserDataPublic.mutex.RUnlock()

	return argCopy
}

// MinimockToRepoUserDataPublicDone returns true if the count of the ToRepoUserDataPublic invocations corresponds
// the number of defined expectations
func (m *RepoConverterMock) MinimockToRepoUserDataPublicDone() bool {
	if m.ToRepoUserDataPublicMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToRepoUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToRepoUserDataPublicMock.invocationsDone()
}

// MinimockToRepoUserDataPublicInspect logs each unmet expectation
func (m *RepoConverterMock) MinimockToRepoUserDataPublicInspect() {
	for _, e := range m.ToRepoUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPublic at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToRepoUserDataPublicCounter := mm_atomic.LoadUint64(&m.afterToRepoUserDataPublicCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToRepoUserDataPublicMock.defaultExpectation != nil && afterToRepoUserDataPublicCounter < 1 {
		if m.ToRepoUserDataPublicMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPublic at\n%s", m.ToRepoUserDataPublicMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPublic at\n%s with params: %#v", m.ToRepoUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *m.ToRepoUserDataPublicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToRepoUserDataPublic != nil && afterToRepoUserDataPublicCounter < 1 {
		m.t.Errorf("Expected call to RepoConverterMock.ToRepoUserDataPublic at\n%s", m.funcToRepoUserDataPublicOrigin)
	}

	if !m.ToRepoUserDataPublicMock.invocationsDone() && afterToRepoUserDataPublicCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoConverterMock.ToRepoUserDataPublic at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToRepoUserDataPublicMock.expectedInvocations), m.ToRepoUserDataPublicMock.expectedInvocationsOrigin, afterToRepoUserDataPublicCounter)
	}
}

type mRepoConverterMockToServiceUserDataPublic struct {
	optional           bool
	mock               *RepoConverterMock
	defaultExpectation *RepoConverterMockToServiceUserDataPublicExpectation
	expectations       []*RepoConverterMockToServiceUserDataPublicExpectation

	callArgs []*RepoConverterMockToServiceUserDataPublicParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepoConverterMockToServiceUserDataPublicExpectation specifies expectation struct of the RepoConverter.ToServiceUserDataPublic
type RepoConverterMockToServiceUserDataPublicExpectation struct {
	mock               *RepoConverterMock
	params             *RepoConverterMockToServiceUserDataPublicParams
	paramPtrs          *RepoConverterMockToServiceUserDataPublicParamPtrs
	expectationOrigins RepoConverterMockToServiceUserDataPublicExpectationOrigins
	results            *RepoConverterMockToServiceUserDataPublicResults
	returnOrigin       string
	Counter            uint64
}

// RepoConverterMockToServiceUserDataPublicParams contains parameters of the RepoConverter.ToServiceUserDataPublic
type RepoConverterMockToServiceUserDataPublicParams struct {
	src *repoModel.UserDataPublic
}

// RepoConverterMockToServiceUserDataPublicParamPtrs contains pointers to parameters of the RepoConverter.ToServiceUserDataPublic
type RepoConverterMockToServiceUserDataPublicParamPtrs struct {
	src **repoModel.UserDataPublic
}

// RepoConverterMockToServiceUserDataPublicResults contains results of the RepoConverter.ToServiceUserDataPublic
type RepoConverterMockToServiceUserDataPublicResults struct {
	up1 *serviceModel.UserDataPublic
}

// RepoConverterMockToServiceUserDataPublicOrigins contains origins of expectations of the RepoConverter.ToServiceUserDataPublic
type RepoConverterMockToServiceUserDataPublicExpectationOrigins struct {
	origin    string
	originSrc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Optional() *mRepoConverterMockToServiceUserDataPublic {
	mmToServiceUserDataPublic.optional = true
	return mmToServiceUserDataPublic
}

// Expect sets up expected params for RepoConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Expect(src *repoModel.UserDataPublic) *mRepoConverterMockToServiceUserDataPublic {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	if mmToServiceUserDataPublic.defaultExpectation == nil {
		mmToServiceUserDataPublic.defaultExpectation = &RepoConverterMockToServiceUserDataPublicExpectation{}
	}

	if mmToServiceUserDataPublic.defaultExpectation.paramPtrs != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToServiceUserDataPublic mock is already set by ExpectParams functions")
	}

	mmToServiceUserDataPublic.defaultExpectation.params = &RepoConverterMockToServiceUserDataPublicParams{src}
	mmToServiceUserDataPublic.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmToServiceUserDataPublic.expectations {
		if minimock.Equal(e.params, mmToServiceUserDataPublic.defaultExpectation.params) {
			mmToServiceUserDataPublic.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToServiceUserDataPublic.defaultExpectation.params)
		}
	}

	return mmToServiceUserDataPublic
}

// ExpectSrcParam1 sets up expected param src for RepoConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) ExpectSrcParam1(src *repoModel.UserDataPublic) *mRepoConverterMockToServiceUserDataPublic {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	if mmToServiceUserDataPublic.defaultExpectation == nil {
		mmToServiceUserDataPublic.defaultExpectation = &RepoConverterMockToServiceUserDataPublicExpectation{}
	}

	if mmToServiceUserDataPublic.defaultExpectation.params != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToServiceUserDataPublic mock is already set by Expect")
	}

	if mmToServiceUserDataPublic.defaultExpectation.paramPtrs == nil {
		mmToServiceUserDataPublic.defaultExpectation.paramPtrs = &RepoConverterMockToServiceUserDataPublicParamPtrs{}
	}
	mmToServiceUserDataPublic.defaultExpectation.paramPtrs.src = &src
	mmToServiceUserDataPublic.defaultExpectation.expectationOrigins.originSrc = minimock.CallerInfo(1)

	return mmToServiceUserDataPublic
}

// Inspect accepts an inspector function that has same arguments as the RepoConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Inspect(f func(src *repoModel.UserDataPublic)) *mRepoConverterMockToServiceUserDataPublic {
	if mmToServiceUserDataPublic.mock.inspectFuncToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("Inspect function is already set for RepoConverterMock.ToServiceUserDataPublic")
	}

	mmToServiceUserDataPublic.mock.inspectFuncToServiceUserDataPublic = f

	return mmToServiceUserDataPublic
}

// Return sets up results that will be returned by RepoConverter.ToServiceUserDataPublic
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Return(up1 *serviceModel.UserDataPublic) *RepoConverterMock {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	if mmToServiceUserDataPublic.defaultExpectation == nil {
		mmToServiceUserDataPublic.defaultExpectation = &RepoConverterMockToServiceUserDataPublicExpectation{mock: mmToServiceUserDataPublic.mock}
	}
	mmToServiceUserDataPublic.defaultExpectation.results = &RepoConverterMockToServiceUserDataPublicResults{up1}
	mmToServiceUserDataPublic.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPublic.mock
}

// Set uses given function f to mock the RepoConverter.ToServiceUserDataPublic method
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Set(f func(src *repoModel.UserDataPublic) (up1 *serviceModel.UserDataPublic)) *RepoConverterMock {
	if mmToServiceUserDataPublic.defaultExpectation != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("Default expectation is already set for the RepoConverter.ToServiceUserDataPublic method")
	}

	if len(mmToServiceUserDataPublic.expectations) > 0 {
		mmToServiceUserDataPublic.mock.t.Fatalf("Some expectations are already set for the RepoConverter.ToServiceUserDataPublic method")
	}

	mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic = f
	mmToServiceUserDataPublic.mock.funcToServiceUserDataPublicOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPublic.mock
}

// When sets expectation for the RepoConverter.ToServiceUserDataPublic which will trigger the result defined by the following
// Then helper
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) When(src *repoModel.UserDataPublic) *RepoConverterMockToServiceUserDataPublicExpectation {
	if mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.mock.t.Fatalf("RepoConverterMock.ToServiceUserDataPublic mock is already set by Set")
	}

	expectation := &RepoConverterMockToServiceUserDataPublicExpectation{
		mock:               mmToServiceUserDataPublic.mock,
		params:             &RepoConverterMockToServiceUserDataPublicParams{src},
		expectationOrigins: RepoConverterMockToServiceUserDataPublicExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmToServiceUserDataPublic.expectations = append(mmToServiceUserDataPublic.expectations, expectation)
	return expectation
}

// Then sets up RepoConverter.ToServiceUserDataPublic return parameters for the expectation previously defined by the When method
func (e *RepoConverterMockToServiceUserDataPublicExpectation) Then(up1 *serviceModel.UserDataPublic) *RepoConverterMock {
	e.results = &RepoConverterMockToServiceUserDataPublicResults{up1}
	return e.mock
}

// Times sets number of times RepoConverter.ToServiceUserDataPublic should be invoked
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Times(n uint64) *mRepoConverterMockToServiceUserDataPublic {
	if n == 0 {
		mmToServiceUserDataPublic.mock.t.Fatalf("Times of RepoConverterMock.ToServiceUserDataPublic mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmToServiceUserDataPublic.expectedInvocations, n)
	mmToServiceUserDataPublic.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmToServiceUserDataPublic
}

func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) invocationsDone() bool {
	if len(mmToServiceUserDataPublic.expectations) == 0 && mmToServiceUserDataPublic.defaultExpectation == nil && mmToServiceUserDataPublic.mock.funcToServiceUserDataPublic == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmToServiceUserDataPublic.mock.afterToServiceUserDataPublicCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmToServiceUserDataPublic.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ToServiceUserDataPublic implements mm_repository.RepoConverter
func (mmToServiceUserDataPublic *RepoConverterMock) ToServiceUserDataPublic(src *repoModel.UserDataPublic) (up1 *serviceModel.UserDataPublic) {
	mm_atomic.AddUint64(&mmToServiceUserDataPublic.beforeToServiceUserDataPublicCounter, 1)
	defer mm_atomic.AddUint64(&mmToServiceUserDataPublic.afterToServiceUserDataPublicCounter, 1)

	mmToServiceUserDataPublic.t.Helper()

	if mmToServiceUserDataPublic.inspectFuncToServiceUserDataPublic != nil {
		mmToServiceUserDataPublic.inspectFuncToServiceUserDataPublic(src)
	}

	mm_params := RepoConverterMockToServiceUserDataPublicParams{src}

	// Record call args
	mmToServiceUserDataPublic.ToServiceUserDataPublicMock.mutex.Lock()
	mmToServiceUserDataPublic.ToServiceUserDataPublicMock.callArgs = append(mmToServiceUserDataPublic.ToServiceUserDataPublicMock.callArgs, &mm_params)
	mmToServiceUserDataPublic.ToServiceUserDataPublicMock.mutex.Unlock()

	for _, e := range mmToServiceUserDataPublic.ToServiceUserDataPublicMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1
		}
	}

	if mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.Counter, 1)
		mm_want := mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.params
		mm_want_ptrs := mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.paramPtrs

		mm_got := RepoConverterMockToServiceUserDataPublicParams{src}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.src != nil && !minimock.Equal(*mm_want_ptrs.src, mm_got.src) {
				mmToServiceUserDataPublic.t.Errorf("RepoConverterMock.ToServiceUserDataPublic got unexpected parameter src, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.expectationOrigins.originSrc, *mm_want_ptrs.src, mm_got.src, minimock.Diff(*mm_want_ptrs.src, mm_got.src))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToServiceUserDataPublic.t.Errorf("RepoConverterMock.ToServiceUserDataPublic got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToServiceUserDataPublic.ToServiceUserDataPublicMock.defaultExpectation.results
		if mm_results == nil {
			mmToServiceUserDataPublic.t.Fatal("No results are set for the RepoConverterMock.ToServiceUserDataPublic")
		}
		return (*mm_results).up1
	}
	if mmToServiceUserDataPublic.funcToServiceUserDataPublic != nil {
		return mmToServiceUserDataPublic.funcToServiceUserDataPublic(src)
	}
	mmToServiceUserDataPublic.t.Fatalf("Unexpected call to RepoConverterMock.ToServiceUserDataPublic. %v", src)
	return
}

// ToServiceUserDataPublicAfterCounter returns a count of finished RepoConverterMock.ToServiceUserDataPublic invocations
func (mmToServiceUserDataPublic *RepoConverterMock) ToServiceUserDataPublicAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToServiceUserDataPublic.afterToServiceUserDataPublicCounter)
}

// ToServiceUserDataPublicBeforeCounter returns a count of RepoConverterMock.ToServiceUserDataPublic invocations
func (mmToServiceUserDataPublic *RepoConverterMock) ToServiceUserDataPublicBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToServiceUserDataPublic.beforeToServiceUserDataPublicCounter)
}

// Calls returns a list of arguments used in each call to RepoConverterMock.ToServiceUserDataPublic.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToServiceUserDataPublic *mRepoConverterMockToServiceUserDataPublic) Calls() []*RepoConverterMockToServiceUserDataPublicParams {
	mmToServiceUserDataPublic.mutex.RLock()

	argCopy := make([]*RepoConverterMockToServiceUserDataPublicParams, len(mmToServiceUserDataPublic.callArgs))
	copy(argCopy, mmToServiceUserDataPublic.callArgs)

	mmToServiceUserDataPublic.mutex.RUnlock()

	return argCopy
}

// MinimockToServiceUserDataPublicDone returns true if the count of the ToServiceUserDataPublic invocations corresponds
// the number of defined expectations
func (m *RepoConverterMock) MinimockToServiceUserDataPublicDone() bool {
	if m.ToServiceUserDataPublicMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ToServiceUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ToServiceUserDataPublicMock.invocationsDone()
}

// MinimockToServiceUserDataPublicInspect logs each unmet expectation
func (m *RepoConverterMock) MinimockToServiceUserDataPublicInspect() {
	for _, e := range m.ToServiceUserDataPublicMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoConverterMock.ToServiceUserDataPublic at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterToServiceUserDataPublicCounter := mm_atomic.LoadUint64(&m.afterToServiceUserDataPublicCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ToServiceUserDataPublicMock.defaultExpectation != nil && afterToServiceUserDataPublicCounter < 1 {
		if m.ToServiceUserDataPublicMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepoConverterMock.ToServiceUserDataPublic at\n%s", m.ToServiceUserDataPublicMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepoConverterMock.ToServiceUserDataPublic at\n%s with params: %#v", m.ToServiceUserDataPublicMock.defaultExpectation.expectationOrigins.origin, *m.ToServiceUserDataPublicMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToServiceUserDataPublic != nil && afterToServiceUserDataPublicCounter < 1 {
		m.t.Errorf("Expected call to RepoConverterMock.ToServiceUserDataPublic at\n%s", m.funcToServiceUserDataPublicOrigin)
	}

	if !m.ToServiceUserDataPublicMock.invocationsDone() && afterToServiceUserDataPublicCounter > 0 {
		m.t.Errorf("Expected %d calls to RepoConverterMock.ToServiceUserDataPublic at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ToServiceUserDataPublicMock.expectedInvocations), m.ToServiceUserDataPublicMock.expectedInvocationsOrigin, afterToServiceUserDataPublicCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepoConverterMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockToRepoUserDataPrivateInspect()

			m.MinimockToRepoUserDataPublicInspect()

			m.MinimockToServiceUserDataPublicInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepoConverterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepoConverterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockToRepoUserDataPrivateDone() &&
		m.MinimockToRepoUserDataPublicDone() &&
		m.MinimockToServiceUserDataPublicDone()
}
